<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LED Matrix Control Panel - v3</title>

    <!-- HTMX for dynamic content loading -->
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://unpkg.com/htmx.org/dist/ext/sse.js"></script>
    <script src="https://unpkg.com/htmx.org/dist/ext/json-enc.js"></script>

    <!-- Alpine.js for reactive components -->
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>

    <!-- Font Awesome icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <!-- Custom v3 styles -->
    <link rel="stylesheet" href="{{ url_for('static', filename='v3/app.css') }}">
</head>
<body x-data="app()" class="bg-gray-50 min-h-screen">
    <!-- Header -->
    <header class="bg-white shadow-md border-b border-gray-200">
        <div class="mx-auto px-4 sm:px-6 lg:px-8 xl:px-12 2xl:px-16" style="max-width: 100%;">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center">
                    <h1 class="text-xl font-bold text-gray-900">
                        <i class="fas fa-tv text-blue-600 mr-2"></i>
                        LED Matrix Control - v3
                    </h1>
                </div>

                <!-- Connection status -->
                <div class="flex items-center space-x-4">
                    <div id="connection-status" class="flex items-center space-x-2 text-sm">
                        <div class="w-2 h-2 bg-red-500 rounded-full"></div>
                        <span class="text-gray-600">Disconnected</span>
                    </div>

                    <!-- System stats (populated via SSE) -->
                    <div class="hidden lg:flex items-center space-x-4 text-sm text-gray-600 xl:space-x-6 2xl:space-x-8">
                        <span id="cpu-stat" class="flex items-center space-x-1">
                            <i class="fas fa-microchip"></i>
                            <span>--%</span>
                        </span>
                        <span id="memory-stat" class="flex items-center space-x-1">
                            <i class="fas fa-memory"></i>
                            <span>--%</span>
                        </span>
                        <span id="temp-stat" class="flex items-center space-x-1">
                            <i class="fas fa-thermometer-half"></i>
                            <span>--°C</span>
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main content -->
    <main class="mx-auto px-4 sm:px-6 lg:px-8 xl:px-12 2xl:px-16 py-8" style="max-width: 100%;">
        <!-- Navigation tabs -->
        <nav class="mb-8">
            <!-- First row - System tabs -->
            <div class="border-b border-gray-200 mb-4">
                <nav class="-mb-px flex space-x-4 lg:space-x-6 xl:space-x-8 overflow-x-auto">
                    <button @click="activeTab = 'overview'"
                            :class="activeTab === 'overview' ? 'border-blue-600 text-blue-600 font-semibold' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'"
                            class="whitespace-nowrap py-2 px-1 lg:px-2 xl:px-3 border-b-2 font-medium text-sm transition-colors">
                        <i class="fas fa-tachometer-alt mr-2"></i>Overview
                    </button>
                    <button @click="activeTab = 'general'"
                            :class="activeTab === 'general' ? 'border-blue-600 text-blue-600 font-semibold' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'"
                            class="whitespace-nowrap py-2 px-1 lg:px-2 xl:px-3 border-b-2 font-medium text-sm transition-colors">
                        <i class="fas fa-sliders-h mr-2"></i>General
                    </button>
                    <button @click="activeTab = 'wifi'"
                            :class="activeTab === 'wifi' ? 'border-blue-600 text-blue-600 font-semibold' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'"
                            class="whitespace-nowrap py-2 px-1 lg:px-2 xl:px-3 border-b-2 font-medium text-sm transition-colors">
                        <i class="fas fa-wifi mr-2"></i>WiFi
                    </button>
                    <button @click="activeTab = 'schedule'"
                            :class="activeTab === 'schedule' ? 'border-blue-600 text-blue-600 font-semibold' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'"
                            class="whitespace-nowrap py-2 px-1 lg:px-2 xl:px-3 border-b-2 font-medium text-sm transition-colors">
                        <i class="fas fa-clock mr-2"></i>Schedule
                    </button>
                    <button @click="activeTab = 'display'"
                            :class="activeTab === 'display' ? 'border-blue-600 text-blue-600 font-semibold' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'"
                            class="whitespace-nowrap py-2 px-1 lg:px-2 xl:px-3 border-b-2 font-medium text-sm transition-colors">
                        <i class="fas fa-desktop mr-2"></i>Display
                    </button>
                    <button @click="activeTab = 'config-editor'"
                            :class="activeTab === 'config-editor' ? 'border-blue-600 text-blue-600 font-semibold' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'"
                            class="whitespace-nowrap py-2 px-1 lg:px-2 xl:px-3 border-b-2 font-medium text-sm transition-colors">
                        <i class="fas fa-file-code mr-2"></i>Config Editor
                    </button>
                    <button @click="activeTab = 'fonts'"
                            :class="activeTab === 'fonts' ? 'border-blue-600 text-blue-600 font-semibold' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'"
                            class="whitespace-nowrap py-2 px-1 lg:px-2 xl:px-3 border-b-2 font-medium text-sm transition-colors">
                        <i class="fas fa-font mr-2"></i>Fonts
                    </button>
                    <button @click="activeTab = 'logs'"
                            :class="activeTab === 'logs' ? 'border-blue-600 text-blue-600 font-semibold' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'"
                            class="whitespace-nowrap py-2 px-1 lg:px-2 xl:px-3 border-b-2 font-medium text-sm transition-colors">
                        <i class="fas fa-file-alt mr-2"></i>Logs
                    </button>
                    <button @click="activeTab = 'cache'"
                            :class="activeTab === 'cache' ? 'border-blue-600 text-blue-600 font-semibold' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'"
                            class="whitespace-nowrap py-2 px-1 lg:px-2 xl:px-3 border-b-2 font-medium text-sm transition-colors">
                        <i class="fas fa-database mr-2"></i>Cache
                    </button>
                </nav>
            </div>

            <!-- Second row - Plugin tabs (populated dynamically) -->
            <div id="plugin-tabs-row" class="border-b border-gray-200">
                <nav class="-mb-px flex space-x-4 lg:space-x-6 xl:space-x-8 overflow-x-auto">
                    <button @click="activeTab = 'plugins'; $nextTick(() => { if (typeof htmx !== 'undefined' && !document.getElementById('plugins-content').hasAttribute('data-loaded')) { htmx.trigger('#plugins-content', 'load'); } })"
                            :class="activeTab === 'plugins' ? 'border-blue-600 text-blue-600 font-semibold' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'"
                            class="whitespace-nowrap py-2 px-1 lg:px-2 xl:px-3 border-b-2 font-medium text-sm transition-colors">
                        <i class="fas fa-plug mr-2"></i>Plugin Manager
                    </button>
                    <!-- Installed plugin tabs will be added here dynamically -->
                </nav>
            </div>
        </nav>

        <!-- Tab content -->
        <div id="tab-content" class="space-y-6">
            <!-- Overview tab -->
            <div x-show="activeTab === 'overview'" x-transition>
                <div id="overview-content" hx-get="/v3/partials/overview" hx-trigger="load" hx-swap="innerHTML">
                    <div class="animate-pulse">
                        <div class="bg-white rounded-lg shadow p-6">
                            <div class="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
                            <div class="h-32 bg-gray-200 rounded"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- General tab -->
            <div x-show="activeTab === 'general'" x-transition>
                <div id="general-content" hx-get="/v3/partials/general" hx-trigger="load" hx-swap="innerHTML">
                    <div class="animate-pulse">
                        <div class="bg-white rounded-lg shadow p-6">
                            <div class="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
                            <div class="space-y-4">
                                <div class="h-10 bg-gray-200 rounded"></div>
                                <div class="h-10 bg-gray-200 rounded"></div>
                                <div class="h-10 bg-gray-200 rounded"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- WiFi tab -->
            <div x-show="activeTab === 'wifi'" x-transition>
                <div id="wifi-content" hx-get="/v3/partials/wifi" hx-trigger="load" hx-swap="innerHTML">
                    <div class="animate-pulse">
                        <div class="bg-white rounded-lg shadow p-6">
                            <div class="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
                            <div class="space-y-4">
                                <div class="h-10 bg-gray-200 rounded"></div>
                                <div class="h-10 bg-gray-200 rounded"></div>
                                <div class="h-10 bg-gray-200 rounded"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Schedule tab -->
            <div x-show="activeTab === 'schedule'" x-transition>
                <div id="schedule-content" hx-get="/v3/partials/schedule" hx-trigger="load" hx-swap="innerHTML">
                    <div class="animate-pulse">
                        <div class="bg-white rounded-lg shadow p-6">
                            <div class="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
                            <div class="space-y-4">
                                <div class="h-10 bg-gray-200 rounded"></div>
                                <div class="h-10 bg-gray-200 rounded"></div>
                                <div class="h-10 bg-gray-200 rounded"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Display tab -->
            <div x-show="activeTab === 'display'" x-transition>
                <div id="display-content" hx-get="/v3/partials/display" hx-trigger="load" hx-swap="innerHTML">
                    <div class="animate-pulse">
                        <div class="bg-white rounded-lg shadow p-6">
                            <div class="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div class="h-32 bg-gray-200 rounded"></div>
                                <div class="h-32 bg-gray-200 rounded"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Config Editor tab -->
            <div x-show="activeTab === 'config-editor'" x-transition>
                <div id="config-editor-content" hx-get="/v3/partials/raw-json" hx-trigger="load" hx-swap="innerHTML">
                    <div class="animate-pulse">
                        <div class="bg-white rounded-lg shadow p-6">
                            <div class="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
                            <div class="space-y-4">
                                <div class="h-64 bg-gray-200 rounded"></div>
                                <div class="h-64 bg-gray-200 rounded"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Plugins tab -->
            <div x-show="activeTab === 'plugins'" 
                 x-transition
                 x-effect="if (activeTab === 'plugins') { 
                     const content = document.getElementById('plugins-content');
                     if (content && typeof htmx !== 'undefined' && !content.hasAttribute('data-loaded')) { 
                         setTimeout(() => {
                             htmx.trigger('#plugins-content', 'load');
                             console.log('Triggered plugins content load');
                         }, 100); 
                     }
                 }">
                <div id="plugins-content" 
                     hx-get="/v3/partials/plugins" 
                     hx-trigger="load" 
                     hx-swap="innerHTML"
                     hx-on::after-swap="
                        this.setAttribute('data-loaded', 'true'); 
                        console.log('Plugins content loaded, triggering initialization...'); 
                        setTimeout(() => {
                            if (window.initPluginsPage && typeof window.initPluginsPage === 'function') {
                                console.log('Calling initPluginsPage...');
                                window.pluginManager.initialized = false;
                                window.initPluginsPage();
                            } else if (typeof initializePluginPageWhenReady === 'function') {
                                console.log('Calling initializePluginPageWhenReady...');
                                window.pluginManager.initialized = false;
                                initializePluginPageWhenReady();
                            } else {
                                console.error('Neither initPluginsPage nor initializePluginPageWhenReady found!');
                            }
                        }, 200);
                     ">
                    <div class="animate-pulse">
                        <div class="bg-white rounded-lg shadow p-6">
                            <div class="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                <div class="h-24 bg-gray-200 rounded"></div>
                                <div class="h-24 bg-gray-200 rounded"></div>
                                <div class="h-24 bg-gray-200 rounded"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Fonts tab -->
            <div x-show="activeTab === 'fonts'" x-transition>
                <div id="fonts-content" hx-get="/v3/partials/fonts" hx-trigger="load" hx-swap="innerHTML">
                    <div class="animate-pulse">
                        <div class="bg-white rounded-lg shadow p-6">
                            <div class="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
                            <div class="space-y-4">
                                <div class="h-20 bg-gray-200 rounded"></div>
                                <div class="h-20 bg-gray-200 rounded"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Logs tab -->
            <div x-show="activeTab === 'logs'" x-transition>
                <div id="logs-content" hx-get="/v3/partials/logs" hx-trigger="load" hx-swap="innerHTML">
                    <div class="animate-pulse">
                        <div class="bg-white rounded-lg shadow p-6">
                            <div class="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
                            <div class="h-96 bg-gray-200 rounded"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Cache tab -->
            <div x-show="activeTab === 'cache'" x-transition>
                <div id="cache-content" hx-get="/v3/partials/cache" hx-trigger="load" hx-swap="innerHTML">
                    <div class="animate-pulse">
                        <div class="bg-white rounded-lg shadow p-6">
                            <div class="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
                            <div class="h-64 bg-gray-200 rounded"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Dynamic Plugin Tabs -->
            <template x-for="plugin in installedPlugins" :key="plugin.id">
                <div x-show="activeTab === plugin.id" x-transition>
                    <div class="bg-white rounded-lg shadow p-6">
                        <div class="border-b border-gray-200 pb-4 mb-6">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h2 class="text-lg font-semibold text-gray-900" x-text="plugin.name || plugin.id"></h2>
                                    <p class="mt-1 text-sm text-gray-600" x-text="plugin.description || 'Plugin configuration'"></p>
                                </div>
                                <div class="flex items-center space-x-4">
                                    <label class="flex items-center">
                                        <input type="checkbox"
                                               x-bind:checked="plugin.enabled"
                                               x-on:change="togglePluginFromTab(plugin.id, $event.target.checked)"
                                               class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                                        <span class="ml-2 text-sm" x-bind:class="plugin.enabled ? 'text-green-600' : 'text-gray-500'">
                                            <span x-text="plugin.enabled ? 'Enabled' : 'Disabled'"></span>
                                        </span>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <!-- Plugin Configuration Form -->
                        <div>
                            <div x-data="{
                                    loading: true,
                                    config: {},
                                    schema: {},
                                    webUiActions: [],
                                    onDemandRefreshing: false,
                                    onDemandStopping: false,
                                    get onDemandStore() {
                                        if (window.Alpine && typeof Alpine.store === 'function' && Alpine.store('onDemand')) {
                                            return Alpine.store('onDemand');
                                        }
                                        return window.__onDemandStore || { loading: true, state: {}, service: {}, error: null, lastUpdated: null };
                                    },
                                    get isOnDemandLoading() {
                                        const store = this.onDemandStore || {};
                                        return !!store.loading;
                                    },
                                    get onDemandState() {
                                        const store = this.onDemandStore || {};
                                        return store.state || {};
                                    },
                                    get onDemandService() {
                                        const store = this.onDemandStore || {};
                                        return store.service || {};
                                    },
                                    get onDemandError() {
                                        const store = this.onDemandStore || {};
                                        return store.error || null;
                                    },
                                    get onDemandActive() {
                                        const state = this.onDemandState;
                                        return !!(state.active && state.plugin_id === plugin.id);
                                    },
                                    resolvePluginName() {
                                        return plugin.name || plugin.id;
                                    },
                                    resolvePluginDisplayName(id) {
                                        if (!id) {
                                            return 'Another plugin';
                                        }
                                        const list = window.installedPlugins || [];
                                        const match = Array.isArray(list) ? list.find(p => p.id === id) : null;
                                        return match ? (match.name || match.id) : id;
                                    },
                                    formatDuration(value) {
                                        if (value === undefined || value === null) {
                                            return '';
                                        }
                                        const total = Number(value);
                                        if (Number.isNaN(total)) {
                                            return '';
                                        }
                                        const seconds = Math.max(0, Math.round(total));
                                        const minutes = Math.floor(seconds / 60);
                                        const remainingSeconds = seconds % 60;
                                        if (minutes > 0) {
                                            return `${minutes}m${remainingSeconds > 0 ? ` ${remainingSeconds}s` : ''}`;
                                        }
                                        return `${remainingSeconds}s`;
                                    },
                                    get onDemandStatusText() {
                                        if (this.isOnDemandLoading) {
                                            return 'Loading on-demand status...';
                                        }
                                        if (this.onDemandError) {
                                            return `On-demand error: ${this.onDemandError}`;
                                        }
                                        const state = this.onDemandState;
                                        if (state.active) {
                                            const activeName = this.resolvePluginDisplayName(state.plugin_id);
                                            if (state.plugin_id !== plugin.id) {
                                                return `${activeName} is running on-demand.`;
                                            }
                                            const modeLabel = state.mode ? ` (${state.mode})` : '';
                                            const remaining = this.formatDuration(state.remaining);
                                            const duration = this.formatDuration(state.duration);
                                            let message = `${this.resolvePluginName()}${modeLabel} is running on-demand`;
                                            if (remaining) {
                                                message += ` — ${remaining} remaining`;
                                            } else if (duration) {
                                                message += ` — duration ${duration}`;
                                            } else {
                                                message += ' — until stopped';
                                            }
                                            return message;
                                        }
                                        const lastEvent = state.last_event ? state.last_event.replace(/-/g, ' ') : null;
                                        if (lastEvent && lastEvent !== 'cleared') {
                                            return `No on-demand session active (last event: ${lastEvent})`;
                                        }
                                        return 'No on-demand session active.';
                                    },
                                    get onDemandStatusClass() {
                                        if (this.isOnDemandLoading) return 'text-blue-600';
                                        if (this.onDemandError) return 'text-red-600';
                                        if (this.onDemandActive) return 'text-green-600';
                                        return 'text-blue-600';
                                    },
                                    get onDemandServiceText() {
                                        if (this.isOnDemandLoading) {
                                            return 'Checking display service status...';
                                        }
                                        if (this.onDemandError) {
                                            return 'Display service status unavailable.';
                                        }
                                        if (this.onDemandService.active) {
                                            return 'Display service is running.';
                                        }
                                        const serviceError = this.onDemandService.stderr || this.onDemandService.error;
                                        return serviceError ? `Display service inactive (${serviceError})` : 'Display service is not running.';
                                    },
                                    get onDemandServiceClass() {
                                        if (this.isOnDemandLoading) return 'text-blue-500';
                                        if (this.onDemandError) return 'text-red-500';
                                        return this.onDemandService.active ? 'text-blue-500' : 'text-red-500';
                                    },
                                    get onDemandLastUpdated() {
                                        const store = this.onDemandStore || {};
                                        if (!store.lastUpdated) {
                                            return '';
                                        }
                                        const deltaSeconds = Math.round((Date.now() - store.lastUpdated) / 1000);
                                        if (deltaSeconds < 5) return 'Just now';
                                        if (deltaSeconds < 60) return `${deltaSeconds}s ago`;
                                        const minutes = Math.round(deltaSeconds / 60);
                                        if (minutes < 60) return `${minutes}m ago`;
                                        const hours = Math.round(minutes / 60);
                                        return `${hours}h ago`;
                                    },
                                    get canStopOnDemand() {
                                        if (this.isOnDemandLoading) return false;
                                        if (this.onDemandError) return true;
                                        return this.onDemandActive;
                                    },
                                    get disableRunButton() {
                                        return !plugin.enabled;
                                    },
                                    get showEnableHint() {
                                        return !plugin.enabled;
                                    },
                                    notify(message, type = 'info') {
                                        if (typeof showNotification === 'function') {
                                            showNotification(message, type);
                                        }
                                    },
                                    refreshOnDemandStatus() {
                                        if (typeof window.loadOnDemandStatus !== 'function') {
                                            this.notify('On-demand status controls unavailable. Refresh the Plugin Manager tab.', 'error');
                                            return;
                                        }
                                        this.onDemandRefreshing = true;
                                        Promise.resolve(window.loadOnDemandStatus(true))
                                            .finally(() => {
                                                this.onDemandRefreshing = false;
                                            });
                                    },
                                    runOnDemand() {
                                        if (!plugin.enabled) {
                                            this.notify('Enable the plugin before running it on-demand.', 'warning');
                                            return;
                                        }
                                        if (typeof window.openOnDemandModal === 'function') {
                                            window.openOnDemandModal(plugin.id);
                                        } else {
                                            this.notify('On-demand modal unavailable. Refresh the Plugin Manager tab.', 'error');
                                        }
                                    },
                                    stopOnDemandWithEvent(stopService = false) {
                                        if (typeof window.requestOnDemandStop !== 'function') {
                                            this.notify('Unable to stop on-demand mode. Refresh the Plugin Manager tab.', 'error');
                                            return;
                                        }
                                        this.onDemandStopping = true;
                                        Promise.resolve(window.requestOnDemandStop({ stopService }))
                                            .finally(() => {
                                                this.onDemandStopping = false;
                                            });
                                    }
                                }" x-init="loadPluginConfig(plugin.id)">
                                <form x-on:submit.prevent="savePluginConfig(plugin.id, $event)">
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                        <!-- Plugin Info -->
                                        <div class="bg-gray-50 rounded-lg p-4">
                                            <h3 class="text-md font-medium text-gray-900 mb-3">Plugin Information</h3>
                                            <dl class="space-y-2">
                                                <div>
                                                    <dt class="text-sm font-medium text-gray-500">Name</dt>
                                                    <dd class="text-sm text-gray-900" x-text="plugin.name || plugin.id"></dd>
                                                </div>
                                                <div>
                                                    <dt class="text-sm font-medium text-gray-500">Author</dt>
                                                    <dd class="text-sm text-gray-900" x-text="plugin.author || 'Unknown'"></dd>
                                                </div>
                                                <div>
                                                    <dt class="text-sm font-medium text-gray-500">Commit</dt>
                                                    <dd class="text-sm text-gray-900" x-text="$root.formatCommitInfo(plugin.last_commit, plugin.branch)"></dd>
                                                </div>
                                                <div>
                                                    <dt class="text-sm font-medium text-gray-500">Date</dt>
                                                    <dd class="text-sm text-gray-900" x-text="$root.formatDateInfo(plugin.last_updated)"></dd>
                                                </div>
                                                <div>
                                                    <dt class="text-sm font-medium text-gray-500">Category</dt>
                                                    <dd class="text-sm text-gray-900" x-text="plugin.category || 'General'"></dd>
                                                </div>
                                                <div x-show="plugin.tags && plugin.tags.length > 0">
                                                    <dt class="text-sm font-medium text-gray-500">Tags</dt>
                                                    <dd class="flex flex-wrap gap-1 mt-1">
                                                        <template x-for="tag in plugin.tags" :key="tag">
                                                            <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded" x-text="tag"></span>
                                                        </template>
                                                    </dd>
                                                </div>
                                            </dl>
                                            <div class="mt-4 pt-4 border-t border-gray-200 space-y-3">
                                                <div class="flex items-center justify-between">
                                                    <div class="flex items-center gap-2">
                                                        <i class="fas fa-bolt text-blue-500"></i>
                                                        <span class="text-sm font-semibold text-gray-900">On-Demand Controls</span>
                                                    </div>
                                                    <div class="flex items-center gap-2">
                                                        <span x-show="!isOnDemandLoading && onDemandLastUpdated" class="text-xs text-gray-500" x-text="onDemandLastUpdated ? ('Updated ' + onDemandLastUpdated) : ''"></span>
                                                        <button type="button"
                                                                class="px-3 py-1.5 text-xs bg-blue-600 hover:bg-blue-700 text-white rounded-md flex items-center gap-1 transition-colors"
                                                                :class="{'opacity-60 cursor-not-allowed': onDemandRefreshing}"
                                                                :disabled="onDemandRefreshing"
                                                                x-on:click="refreshOnDemandStatus">
                                                            <i class="fas fa-sync" :class="onDemandRefreshing ? 'fa-spin' : ''"></i>
                                                            <span>Refresh</span>
                                                        </button>
                                                    </div>
                                                </div>
                                                <p class="text-sm leading-relaxed" :class="onDemandStatusClass" x-text="onDemandStatusText"></p>
                                                <p class="text-xs" :class="onDemandServiceClass" x-text="onDemandServiceText"></p>
                                                <div class="flex flex-wrap gap-2">
                                                    <button type="button"
                                                            class="px-3 py-2 text-sm bg-green-600 hover:bg-green-700 text-white rounded-md flex items-center gap-2 transition-colors"
                                                            :class="{'opacity-60 cursor-not-allowed': disableRunButton || onDemandStopping || onDemandRefreshing}"
                                                            :disabled="disableRunButton || onDemandStopping || onDemandRefreshing"
                                                            x-on:click="runOnDemand">
                                                        <i class="fas fa-play-circle"></i>
                                                        <span>Run On-Demand</span>
                                                    </button>
                                                    <button type="button"
                                                            class="px-3 py-2 text-sm bg-red-600 hover:bg-red-700 text-white rounded-md flex items-center gap-2 transition-colors"
                                                            :class="{'opacity-60 cursor-not-allowed': !canStopOnDemand || onDemandStopping}"
                                                            :disabled="!canStopOnDemand || onDemandStopping"
                                                            x-on:click="stopOnDemandWithEvent($event.shiftKey)">
                                                        <i class="fas fa-stop"></i>
                                                        <span>Stop On-Demand</span>
                                                    </button>
                                                </div>
                                                <p class="text-xs text-amber-600" x-show="showEnableHint">
                                                    Enable this plugin before launching on-demand.
                                                </p>
                                                <p class="text-xs text-gray-400">
                                                    Hold Shift while stopping to also stop the display service.
                                                </p>
                                            </div>
                                        </div>

                                        <!-- Configuration Schema -->
                                        <div class="bg-gray-50 rounded-lg p-4">
                                            <h3 class="text-md font-medium text-gray-900 mb-3">Configuration</h3>
                                            <div class="space-y-4">
                                                <!-- Loading state -->
                                                <div x-show="loading" class="animate-pulse space-y-3">
                                                    <div class="h-4 bg-gray-200 rounded w-3/4"></div>
                                                    <div class="h-10 bg-gray-200 rounded"></div>
                                                    <div class="h-4 bg-gray-200 rounded w-1/2"></div>
                                                    <div class="h-10 bg-gray-200 rounded"></div>
                                                </div>

                                                <!-- Configuration fields loaded dynamically -->
                                                <div x-show="!loading" x-html="generateConfigForm(plugin.id, config, schema, webUiActions)"></div>
                                            </div>
                                        </div>
                                    </div>

                                <!-- Action Buttons -->
                                <div class="flex justify-end space-x-3 mt-6 pt-6 border-t border-gray-200">
                                    <button type="button"
                                            x-on:click="refreshPlugins()"
                                            class="btn bg-gray-600 hover:bg-gray-700 text-white px-4 py-2">
                                        <i class="fas fa-sync-alt mr-2"></i>Refresh All
                                    </button>
                                    <button type="button"
                                            x-on:click="refreshPlugin(plugin.id)"
                                            class="btn bg-gray-600 hover:bg-gray-700 text-white px-4 py-2">
                                        <i class="fas fa-sync-alt mr-2"></i>Refresh
                                    </button>
                                    <button type="button"
                                            x-on:click="updatePlugin(plugin.id)"
                                            class="btn bg-yellow-600 hover:bg-yellow-700 text-white px-4 py-2">
                                        <i class="fas fa-download mr-2"></i>Update
                                    </button>
                                    <button type="button"
                                            x-on:click="uninstallPlugin(plugin.id)"
                                            x-on:click.prevent="if(!confirm('Are you sure you want to uninstall ${plugin.name || plugin.id}?')) return false"
                                            class="btn bg-red-600 hover:bg-red-700 text-white px-4 py-2">
                                        <i class="fas fa-trash mr-2"></i>Uninstall
                                    </button>
                                    <button type="submit" class="btn bg-blue-600 hover:bg-blue-700 text-white px-4 py-2">
                                        <i class="fas fa-save mr-2"></i>Save Configuration
                                    </button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
            </template>
        </div>
    </main>

    <!-- Notifications -->
    <div id="notifications" class="fixed top-4 right-4 z-50 space-y-2"></div>

    <!-- SSE connection for real-time updates -->
    <script>
        // Connect to SSE streams
        const statsSource = new EventSource('/api/v3/stream/stats');
        const displaySource = new EventSource('/api/v3/stream/display');

        statsSource.onmessage = function(event) {
            const data = JSON.parse(event.data);
            updateSystemStats(data);
        };

        displaySource.onmessage = function(event) {
            const data = JSON.parse(event.data);
            updateDisplayPreview(data);
        };

        // Connection status
        statsSource.addEventListener('open', function() {
            document.getElementById('connection-status').innerHTML = `
                <div class="w-2 h-2 bg-green-500 rounded-full"></div>
                <span class="text-gray-600">Connected</span>
            `;
        });

        statsSource.addEventListener('error', function() {
            document.getElementById('connection-status').innerHTML = `
                <div class="w-2 h-2 bg-red-500 rounded-full"></div>
                <span class="text-gray-600">Disconnected</span>
            `;
        });

        function updateSystemStats(data) {
            // Update CPU in header
            const cpuEl = document.getElementById('cpu-stat');
            if (cpuEl && data.cpu_percent !== undefined) {
                const spans = cpuEl.querySelectorAll('span');
                if (spans.length > 0) spans[spans.length - 1].textContent = data.cpu_percent + '%';
            }

            // Update Memory in header
            const memEl = document.getElementById('memory-stat');
            if (memEl && data.memory_used_percent !== undefined) {
                const spans = memEl.querySelectorAll('span');
                if (spans.length > 0) spans[spans.length - 1].textContent = data.memory_used_percent + '%';
            }

            // Update Temperature in header
            const tempEl = document.getElementById('temp-stat');
            if (tempEl && data.cpu_temp !== undefined) {
                const spans = tempEl.querySelectorAll('span');
                if (spans.length > 0) spans[spans.length - 1].textContent = data.cpu_temp + '°C';
            }

            // Update Overview tab stats (if visible)
            const cpuUsageEl = document.getElementById('cpu-usage');
            if (cpuUsageEl && data.cpu_percent !== undefined) {
                cpuUsageEl.textContent = data.cpu_percent + '%';
            }

            const memUsageEl = document.getElementById('memory-usage');
            if (memUsageEl && data.memory_used_percent !== undefined) {
                memUsageEl.textContent = data.memory_used_percent + '%';
            }

            const cpuTempEl = document.getElementById('cpu-temp');
            if (cpuTempEl && data.cpu_temp !== undefined) {
                cpuTempEl.textContent = data.cpu_temp + '°C';
            }

            const displayStatusEl = document.getElementById('display-status');
            if (displayStatusEl) {
                displayStatusEl.textContent = data.service_active ? 'Active' : 'Inactive';
                displayStatusEl.className = data.service_active ?
                    'text-lg font-medium text-green-600' :
                    'text-lg font-medium text-red-600';
            }
        }

        window.__onDemandStore = window.__onDemandStore || {
            loading: true,
            state: {},
            service: {},
            error: null,
            lastUpdated: null
        };

        document.addEventListener('alpine:init', () => {
            if (!Alpine.store('onDemand')) {
                Alpine.store('onDemand', {
                    loading: window.__onDemandStore.loading,
                    state: window.__onDemandStore.state,
                    service: window.__onDemandStore.service,
                    error: window.__onDemandStore.error,
                    lastUpdated: window.__onDemandStore.lastUpdated
                });
            }
            window.__onDemandStore = Alpine.store('onDemand');
        });

        // Alpine.js app function
        function app() {
            return {
                activeTab: 'overview',
                installedPlugins: [],

                init() {
                    // Plugin loading is handled by the pluginManager in plugins.html
                    // when the plugins tab is loaded via HTMX

                    // Initialize installedPlugins from global if available
                    if (typeof window.installedPlugins !== 'undefined') {
                        this.installedPlugins = window.installedPlugins;
                        console.log('Initialized installedPlugins from global:', this.installedPlugins.length);
                    }

                    // Listen for plugin updates from pluginManager
                    document.addEventListener('pluginsUpdated', (event) => {
                        console.log('Received pluginsUpdated event:', event.detail.plugins.length, 'plugins');
                        this.installedPlugins = event.detail.plugins;
                        this.updatePluginTabs();
                    });

                    // Also listen for direct window.installedPlugins changes
                    Object.defineProperty(window, 'installedPlugins', {
                        set: (value) => {
                            console.log('window.installedPlugins changed:', value?.length, 'plugins');
                            this.installedPlugins = value || [];
                            this.updatePluginTabs();
                        },
                        get: () => this.installedPlugins
                    });

                },

                async loadInstalledPlugins() {
                    // If pluginManager exists (plugins.html is loaded), delegate to it
                    if (window.pluginManager) {
                        console.log('Delegating plugin loading to pluginManager...');
                        await window.pluginManager.loadInstalledPlugins();
                        return;
                    }

                    // Otherwise, load plugins directly (fallback for when plugins.html isn't loaded)
                    try {
                        console.log('Loading installed plugins directly...');
                        const response = await fetch('/api/v3/plugins/installed');
                        const data = await response.json();

                        if (data.status === 'success') {
                            this.installedPlugins = data.data.plugins || [];
                            console.log(`Loaded ${this.installedPlugins.length} plugins:`, this.installedPlugins.map(p => p.id));
                            
                            // Debug: Log enabled status for each plugin
                            this.installedPlugins.forEach(plugin => {
                                console.log(`[DEBUG Alpine] Plugin ${plugin.id}: enabled=${plugin.enabled} (type: ${typeof plugin.enabled})`);
                            });
                            
                            this.updatePluginTabs();
                        } else {
                            console.error('Failed to load plugins:', data.message);
                        }
                    } catch (error) {
                        console.error('Error loading installed plugins:', error);
                    }
                },

                updatePluginTabs(retryCount = 0) {
                    const maxRetries = 5;

                    // Use global installedPlugins if available, otherwise use component's
                    const pluginsToShow = window.installedPlugins || this.installedPlugins || [];
                    console.log('updatePluginTabs called with:', pluginsToShow.length, 'plugins (attempt', retryCount + 1, ')');

                    const pluginTabsRow = document.getElementById('plugin-tabs-row');
                    const pluginTabsNav = pluginTabsRow?.querySelector('nav');

                    console.log('Plugin tabs elements:', {
                        pluginTabsRow: !!pluginTabsRow,
                        pluginTabsNav: !!pluginTabsNav,
                        bodyExists: !!document.body,
                        installedPlugins: pluginsToShow
                    });

                    if (!pluginTabsRow || !pluginTabsNav) {
                        if (retryCount < maxRetries) {
                            console.log('Plugin tabs container not found, retrying...');
                            setTimeout(() => {
                                this.updatePluginTabs(retryCount + 1);
                            }, 500);
                        } else {
                            console.error('Plugin tabs container not found after maximum retries');
                        }
                        return;
                    }

                    console.log(`Updating plugin tabs for ${pluginsToShow.length} plugins`);

                    // Always show the plugin tabs row (Plugin Manager should always be available)
                    console.log('Ensuring plugin tabs row is visible');
                    pluginTabsRow.style.display = 'block';

                    // Clear existing plugin tabs (except the Plugin Manager tab)
                    const existingTabs = pluginTabsNav.querySelectorAll('.plugin-tab');
                    console.log(`Removing ${existingTabs.length} existing plugin tabs`);
                    existingTabs.forEach(tab => tab.remove());

                    // Add tabs for each installed plugin
                    console.log('Adding tabs for plugins:', pluginsToShow.map(p => p.id));
                    pluginsToShow.forEach(plugin => {
                        const tabButton = document.createElement('button');
                        tabButton.type = 'button';
                        tabButton.className = `plugin-tab whitespace-nowrap py-2 px-1 lg:px-2 xl:px-3 border-b-2 font-medium text-sm ${this.activeTab === plugin.id ? 'border-blue-500 text-blue-600' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'}`;
                        tabButton.onclick = () => {
                            this.activeTab = plugin.id;
                        };
                        tabButton.innerHTML = `
                            <i class="fas fa-puzzle-piece mr-2"></i>${this.escapeHtml(plugin.name || plugin.id)}
                        `;

                        // Insert before the closing </nav> tag
                        pluginTabsNav.appendChild(tabButton);
                        console.log('Added tab for plugin:', plugin.id);
                    });

                    console.log('Plugin tabs update completed');
                },


                showNotification(message, type = 'info') {
                    const notifications = document.getElementById('notifications');
                    const notification = document.createElement('div');

                    const colors = {
                        success: 'bg-green-500',
                        error: 'bg-red-500',
                        warning: 'bg-yellow-500',
                        info: 'bg-blue-500'
                    };

                    notification.className = `px-4 py-3 rounded-md text-white text-sm ${colors[type] || colors.info}`;
                    notification.textContent = message;

                    notifications.appendChild(notification);

                    setTimeout(() => {
                        notification.remove();
                    }, 5000);
                },

                escapeHtml(text) {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                },

                async refreshPlugins() {
                    await this.loadInstalledPlugins();
                    await this.searchPluginStore();
                    this.showNotification('Plugin list refreshed', 'success');
                },



                async loadPluginConfig(pluginId) {
                    console.log('Loading config for plugin:', pluginId);
                    this.loading = true;

                    try {
                        // Load config, schema, and installed plugins (for web_ui_actions) in parallel
                        const [configResponse, schemaResponse, pluginsResponse] = await Promise.all([
                            fetch(`/api/v3/plugins/config?plugin_id=${pluginId}`),
                            fetch(`/api/v3/plugins/schema?plugin_id=${pluginId}`),
                            fetch(`/api/v3/plugins/installed`)
                        ]);

                        const [configData, schemaData, pluginsData] = await Promise.all([
                            configResponse.json(),
                            schemaResponse.json(),
                            pluginsResponse.json()
                        ]);

                        if (configData.status === 'success') {
                            this.config = configData.data;
                        }

                        if (schemaData.status === 'success') {
                            this.schema = schemaData.data.schema || {};
                        }

                        // Extract web_ui_actions from installed plugins and update plugin data
                        if (pluginsData.status === 'success' && pluginsData.data && pluginsData.data.plugins) {
                            // Update window.installedPlugins with fresh data (includes commit info)
                            window.installedPlugins = pluginsData.data.plugins;
                            // Update Alpine.js app data
                            this.installedPlugins = pluginsData.data.plugins;
                            
                            const pluginInfo = pluginsData.data.plugins.find(p => p.id === pluginId);
                            this.webUiActions = pluginInfo ? (pluginInfo.web_ui_actions || []) : [];
                            console.log('[DEBUG] Loaded web_ui_actions for', pluginId, ':', this.webUiActions.length, 'actions');
                            console.log('[DEBUG] Updated plugin data with commit info:', pluginInfo ? {
                                last_commit: pluginInfo.last_commit,
                                branch: pluginInfo.branch,
                                last_updated: pluginInfo.last_updated
                            } : 'plugin not found');
                        } else {
                            this.webUiActions = [];
                        }

                        console.log('Loaded config, schema, and actions for', pluginId);
                    } catch (error) {
                        console.error('Error loading plugin config:', error);
                        this.config = { enabled: true, display_duration: 30 };
                        this.schema = {};
                        this.webUiActions = [];
                    } finally {
                        this.loading = false;
                    }
                },

                generateConfigForm(pluginId, config, schema, webUiActions = []) {
                    console.log('[DEBUG] generateConfigForm called with webUiActions:', webUiActions, 'length:', webUiActions ? webUiActions.length : 0);
                    if (!schema || !schema.properties) {
                        return this.generateSimpleConfigForm(config, webUiActions, pluginId);
                    }

                    const generateFieldHtml = (key, prop, value, prefix = '') => {
                        const fullKey = prefix ? `${prefix}.${key}` : key;
                        const label = prop.title || key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        const description = prop.description || '';
                        let html = '';

                        // Handle nested objects
                        if (prop.type === 'object' && prop.properties) {
                            const sectionId = `section-${fullKey.replace(/\./g, '-')}`;
                            const nestedConfig = value || {};
                            const sectionLabel = prop.title || key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            
                            html += `
                                <div class="nested-section border border-gray-300 rounded-lg overflow-hidden mb-4">
                                    <button type="button" 
                                            class="w-full bg-gray-100 hover:bg-gray-200 px-4 py-3 flex items-center justify-between text-left transition-colors"
                                            onclick="toggleNestedSection('${sectionId}')">
                                        <div class="flex-1">
                                            <h4 class="font-semibold text-gray-900">${sectionLabel}</h4>
                                            ${description ? `<p class="text-sm text-gray-600 mt-1">${description}</p>` : ''}
                                        </div>
                                        <i id="${sectionId}-icon" class="fas fa-chevron-down text-gray-500 transition-transform"></i>
                                    </button>
                                    <div id="${sectionId}" class="nested-content bg-gray-50 px-4 py-3 space-y-3" style="display: block;">
                            `;
                            
                            // Recursively generate fields for nested properties
                            Object.entries(prop.properties).forEach(([nestedKey, nestedProp]) => {
                                // Use config value if it exists and is not null (including false), otherwise use schema default
                                // Check if key exists in config and value is not null
                                const hasValue = nestedKey in nestedConfig && nestedConfig[nestedKey] !== null;
                                const nestedValue = hasValue ? nestedConfig[nestedKey] : (nestedProp.default !== undefined ? nestedProp.default : false);
                                html += generateFieldHtml(nestedKey, nestedProp, nestedValue, fullKey);
                            });
                            
                            html += `
                                    </div>
                                </div>
                            `;
                            
                            return html;
                        }

                        // Regular (non-nested) field
                        html += `<div class="form-group">`;
                        html += `<label class="block text-sm font-medium text-gray-700 mb-1">${label}</label>`;

                        if (description) {
                            html += `<p class="text-sm text-gray-600 mb-2">${description}</p>`;
                        }

                        // Generate appropriate input based on type
                        if (prop.type === 'boolean') {
                            html += `<label class="flex items-center">`;
                            html += `<input type="checkbox" name="${fullKey}" ${value ? 'checked' : ''} class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">`;
                            html += `<span class="ml-2 text-sm">Enabled</span>`;
                            html += `</label>`;
                        } else if (prop.type === 'number' || prop.type === 'integer') {
                            const min = prop.minimum !== undefined ? `min="${prop.minimum}"` : '';
                            const max = prop.maximum !== undefined ? `max="${prop.maximum}"` : '';
                            const step = prop.type === 'integer' ? 'step="1"' : 'step="any"';
                            html += `<input type="number" name="${fullKey}" value="${value !== undefined ? value : ''}" ${min} ${max} ${step} class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">`;
                        } else if (prop.type === 'array') {
                            // Check if this is a file upload widget
                            if (prop['x-widget'] === 'file-upload') {
                                // Use the file upload widget from plugins.html
                                // We'll need to call a function that exists in the global scope
                                const uploadConfig = prop['x-upload-config'] || {};
                                const maxFiles = uploadConfig.max_files || 10;
                                const allowedTypes = uploadConfig.allowed_types || ['image/png', 'image/jpeg', 'image/bmp', 'image/gif'];
                                const maxSizeMB = uploadConfig.max_size_mb || 5;
                                
                                const currentImages = Array.isArray(value) ? value : [];
                                const fieldId = fullKey.replace(/\./g, '_');
                                const safePluginId = (uploadConfig.plugin_id || pluginId || 'static-image').toString().replace(/[^a-zA-Z0-9_-]/g, '_');
                                
                                html += `
                                    <div id="${fieldId}_upload_widget" class="mt-1">
                                        <!-- File Upload Drop Zone -->
                                        <div id="${fieldId}_drop_zone" 
                                             class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-blue-400 transition-colors cursor-pointer"
                                             ondrop="window.handleFileDrop(event, this.dataset.fieldId)" 
                                             ondragover="event.preventDefault()" 
                                             data-field-id="${fieldId}"
                                             onclick="document.getElementById(this.dataset.fieldId + '_file_input').click()">
                                            <input type="file" 
                                                   id="${fieldId}_file_input" 
                                                   multiple 
                                                   accept="${allowedTypes.join(',')}"
                                                   style="display: none;"
                                                   data-field-id="${fieldId}"
                                                   onchange="window.handleFileSelect(event, this.dataset.fieldId)">
                                            <i class="fas fa-cloud-upload-alt text-3xl text-gray-400 mb-2"></i>
                                            <p class="text-sm text-gray-600">Drag and drop images here or click to browse</p>
                                            <p class="text-xs text-gray-500 mt-1">Max ${maxFiles} files, ${maxSizeMB}MB each (PNG, JPG, GIF, BMP)</p>
                                        </div>
                                        
                                        <!-- Uploaded Images List -->
                                        <div id="${fieldId}_image_list" class="mt-4 space-y-2">
                                            ${currentImages.map((img, idx) => {
                                                const imgSchedule = img.schedule || {};
                                                const hasSchedule = imgSchedule.enabled && imgSchedule.mode && imgSchedule.mode !== 'always';
                                                let scheduleSummary = 'Always shown';
                                                if (hasSchedule && window.getScheduleSummary) {
                                                    try {
                                                        scheduleSummary = window.getScheduleSummary(imgSchedule) || 'Scheduled';
                                                    } catch (e) {
                                                        scheduleSummary = 'Scheduled';
                                                    }
                                                } else if (hasSchedule) {
                                                    scheduleSummary = 'Scheduled';
                                                }
                                                // Escape the summary for HTML
                                                scheduleSummary = String(scheduleSummary).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                                                
                                                return `
                                                <div id="img_${(img.id || idx).toString().replace(/[^a-zA-Z0-9_-]/g, '_')}" class="bg-gray-50 p-3 rounded-lg border border-gray-200">
                                                    <div class="flex items-center justify-between mb-2">
                                                        <div class="flex items-center space-x-3 flex-1">
                                                            <img src="/${(img.path || '').replace(/&/g, '&amp;').replace(/"/g, '&quot;')}" 
                                                                 alt="${(img.filename || '').replace(/"/g, '&quot;')}" 
                                                                 class="w-16 h-16 object-cover rounded"
                                                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                                            <div style="display:none;" class="w-16 h-16 bg-gray-200 rounded flex items-center justify-center">
                                                                <i class="fas fa-image text-gray-400"></i>
                                                            </div>
                                                            <div class="flex-1 min-w-0">
                                                                <p class="text-sm font-medium text-gray-900 truncate">${String(img.original_filename || img.filename || 'Image').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>
                                                                <p class="text-xs text-gray-500">${img.size ? (Math.round(img.size / 1024) + ' KB') : ''} • ${(img.uploaded_at || '').replace(/&/g, '&amp;')}</p>
                                                                <p class="text-xs text-blue-600 mt-1">
                                                                    <i class="fas fa-clock mr-1"></i>${scheduleSummary}
                                                                </p>
                                                            </div>
                                                        </div>
                                                        <div class="flex items-center space-x-2 ml-4">
                                                            <button type="button" 
                                                                    data-field-id="${fieldId}"
                                                                    data-image-id="${img.id || ''}"
                                                                    data-image-idx="${idx}"
                                                                    onclick="window.openImageSchedule(this.dataset.fieldId, this.dataset.imageId || null, parseInt(this.dataset.imageIdx))"
                                                                    class="text-blue-600 hover:text-blue-800 p-2" 
                                                                    title="Schedule this image">
                                                                <i class="fas fa-calendar-alt"></i>
                                                            </button>
                                                            <button type="button" 
                                                                    data-field-id="${fieldId}"
                                                                    data-image-id="${img.id || ''}"
                                                                    data-plugin-id="${safePluginId}"
                                                                    onclick="window.deleteUploadedImage(this.dataset.fieldId, this.dataset.imageId, this.dataset.pluginId)"
                                                                    class="text-red-600 hover:text-red-800 p-2"
                                                                    title="Delete image">
                                                                <i class="fas fa-trash"></i>
                                                            </button>
                                                        </div>
                                                    </div>
                                                    <!-- Schedule widget will be inserted here when opened -->
                                                    <div id="schedule_${(img.id || idx).toString().replace(/[^a-zA-Z0-9_-]/g, '_')}" class="hidden mt-3 pt-3 border-t border-gray-300"></div>
                                                </div>
                                                `;
                                            }).join('')}
                                        </div>
                                        
                                        <!-- Hidden input to store image data -->
                                        <input type="hidden" id="${fieldId}_images_data" name="${fullKey}" value="${JSON.stringify(currentImages).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;')}">
                                    </div>
                                `;
                            } else {
                                // Regular array input
                                const arrayValue = Array.isArray(value) ? value.join(', ') : '';
                                html += `<input type="text" name="${fullKey}" value="${arrayValue}" placeholder="Enter values separated by commas" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">`;
                                html += `<p class="text-sm text-gray-600 mt-1">Enter values separated by commas</p>`;
                            }
                        } else if (prop.enum) {
                            html += `<select name="${fullKey}" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">`;
                            prop.enum.forEach(option => {
                                const selected = value === option ? 'selected' : '';
                                html += `<option value="${option}" ${selected}>${option}</option>`;
                            });
                            html += `</select>`;
                        } else {
                            // Default to text input
                            const maxLength = prop.maxLength || '';
                            const maxLengthAttr = maxLength ? `maxlength="${maxLength}"` : '';
                            html += `<input type="text" name="${fullKey}" value="${value !== undefined ? value : ''}" ${maxLengthAttr} class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">`;
                        }

                        html += `</div>`;
                        return html;
                    };

                    let formHtml = '';
                    Object.entries(schema.properties).forEach(([key, prop]) => {
                        // Skip the 'enabled' property - it's managed separately via the header toggle
                        if (key === 'enabled') return;
                        // Use config value if key exists and is not null (including false), otherwise use schema default
                        // Check if key exists in config and value is not null
                        const hasValue = key in config && config[key] !== null;
                        const value = hasValue ? config[key] : (prop.default !== undefined ? prop.default : false);
                        formHtml += generateFieldHtml(key, prop, value);
                    });

                    // Add web UI actions section if plugin defines any
                    if (webUiActions && webUiActions.length > 0) {
                        console.log('[DEBUG] Rendering', webUiActions.length, 'actions in tab form');
                        
                        // Map color names to explicit Tailwind classes
                        const colorMap = {
                            'blue': { bg: 'bg-blue-50', border: 'border-blue-200', text: 'text-blue-900', textLight: 'text-blue-700', btn: 'bg-blue-600 hover:bg-blue-700' },
                            'green': { bg: 'bg-green-50', border: 'border-green-200', text: 'text-green-900', textLight: 'text-green-700', btn: 'bg-green-600 hover:bg-green-700' },
                            'red': { bg: 'bg-red-50', border: 'border-red-200', text: 'text-red-900', textLight: 'text-red-700', btn: 'bg-red-600 hover:bg-red-700' },
                            'yellow': { bg: 'bg-yellow-50', border: 'border-yellow-200', text: 'text-yellow-900', textLight: 'text-yellow-700', btn: 'bg-yellow-600 hover:bg-yellow-700' },
                            'purple': { bg: 'bg-purple-50', border: 'border-purple-200', text: 'text-purple-900', textLight: 'text-purple-700', btn: 'bg-purple-600 hover:bg-purple-700' }
                        };
                        
                        formHtml += `
                            <div class="border-t border-gray-200 pt-4 mt-4">
                                <h3 class="text-lg font-semibold text-gray-900 mb-3">Actions</h3>
                                <p class="text-sm text-gray-600 mb-4">${webUiActions[0].section_description || 'Perform actions for this plugin'}</p>
                                
                                <div class="space-y-3">
                        `;
                        
                        webUiActions.forEach((action, index) => {
                            const actionId = `action-${action.id}-${index}`;
                            const statusId = `action-status-${action.id}-${index}`;
                            const bgColor = action.color || 'blue';
                            const colors = colorMap[bgColor] || colorMap['blue'];
                            
                            formHtml += `
                                    <div class="${colors.bg} border ${colors.border} rounded-lg p-4">
                                        <div class="flex items-center justify-between">
                                            <div class="flex-1">
                                                <h4 class="font-medium ${colors.text} mb-1">
                                                    ${action.icon ? `<i class="${action.icon} mr-2"></i>` : ''}${action.title || action.id}
                                                </h4>
                                                <p class="text-sm ${colors.textLight}">${action.description || ''}</p>
                                            </div>
                                            <button type="button" 
                                                    id="${actionId}"
                                                    onclick="executePluginAction('${action.id}', ${index}, '${pluginId}')" 
                                                    class="btn ${colors.btn} text-white px-4 py-2 rounded-md whitespace-nowrap">
                                                ${action.icon ? `<i class="${action.icon} mr-2"></i>` : ''}${action.button_text || action.title || 'Execute'}
                                            </button>
                                        </div>
                                        <div id="${statusId}" class="mt-3 hidden"></div>
                                    </div>
                            `;
                        });
                        
                        formHtml += `
                                </div>
                            </div>
                        `;
                    }

                    return formHtml;
                },

                generateSimpleConfigForm(config, webUiActions = [], pluginId = '') {
                    let actionsHtml = '';
                    if (webUiActions && webUiActions.length > 0) {
                        const colorMap = {
                            'blue': { bg: 'bg-blue-50', border: 'border-blue-200', text: 'text-blue-900', textLight: 'text-blue-700', btn: 'bg-blue-600 hover:bg-blue-700' },
                            'green': { bg: 'bg-green-50', border: 'border-green-200', text: 'text-green-900', textLight: 'text-green-700', btn: 'bg-green-600 hover:bg-green-700' },
                            'red': { bg: 'bg-red-50', border: 'border-red-200', text: 'text-red-900', textLight: 'text-red-700', btn: 'bg-red-600 hover:bg-red-700' },
                            'yellow': { bg: 'bg-yellow-50', border: 'border-yellow-200', text: 'text-yellow-900', textLight: 'text-yellow-700', btn: 'bg-yellow-600 hover:bg-yellow-700' },
                            'purple': { bg: 'bg-purple-50', border: 'border-purple-200', text: 'text-purple-900', textLight: 'text-purple-700', btn: 'bg-purple-600 hover:bg-purple-700' }
                        };
                        
                        actionsHtml = `
                            <div class="border-t border-gray-200 pt-4 mt-4">
                                <h3 class="text-lg font-semibold text-gray-900 mb-3">Actions</h3>
                                <div class="space-y-3">
                        `;
                        webUiActions.forEach((action, index) => {
                            const actionId = `action-${action.id}-${index}`;
                            const statusId = `action-status-${action.id}-${index}`;
                            const bgColor = action.color || 'blue';
                            const colors = colorMap[bgColor] || colorMap['blue'];
                            actionsHtml += `
                                    <div class="${colors.bg} border ${colors.border} rounded-lg p-4">
                                        <div class="flex items-center justify-between">
                                            <div class="flex-1">
                                                <h4 class="font-medium ${colors.text} mb-1">
                                                    ${action.icon ? `<i class="${action.icon} mr-2"></i>` : ''}${action.title || action.id}
                                                </h4>
                                                <p class="text-sm ${colors.textLight}">${action.description || ''}</p>
                                            </div>
                                            <button type="button" 
                                                    id="${actionId}"
                                                    onclick="executePluginAction('${action.id}', ${index}, '${pluginId}')" 
                                                    class="btn ${colors.btn} text-white px-4 py-2 rounded-md">
                                                ${action.icon ? `<i class="${action.icon} mr-2"></i>` : ''}${action.button_text || action.title || 'Execute'}
                                            </button>
                                        </div>
                                        <div id="${statusId}" class="mt-3 hidden"></div>
                                    </div>
                            `;
                        });
                        actionsHtml += `
                                </div>
                            </div>
                        `;
                    }
                    
                    return `
                        <div class="form-group">
                            <label class="block text-sm font-medium text-gray-700 mb-1">Display Duration (seconds)</label>
                            <input type="number" name="display_duration" value="${config.display_duration || 30}" min="5" max="300" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                            <p class="text-sm text-gray-600 mt-1">How long to show this plugin's content</p>
                        </div>
                        ${actionsHtml}
                    `;
                },

                // Helper function to get schema property type for a field path
                getSchemaPropertyType(schema, path) {
                    if (!schema || !schema.properties) return null;
                    
                    const parts = path.split('.');
                    let current = schema.properties;
                    
                    for (let i = 0; i < parts.length; i++) {
                        const part = parts[i];
                        if (current && current[part]) {
                            if (i === parts.length - 1) {
                                return current[part];
                            } else if (current[part].properties) {
                                current = current[part].properties;
                            } else {
                                return null;
                            }
                        } else {
                            return null;
                        }
                    }
                    return null;
                },

                async savePluginConfig(pluginId, event) {
                    try {
                        // Get the form element for this plugin
                        const form = event ? event.target : null;
                        if (!form) {
                            throw new Error('Form element not found');
                        }
                        const formData = new FormData(form);
                        const schema = this.schema || {};
                        
                        // First, collect all checkbox states (including unchecked ones)
                        // Unchecked checkboxes don't appear in FormData, so we need to iterate form elements
                        const flatConfig = {};
                        
                        // Process all form elements to capture all field states
                        for (let i = 0; i < form.elements.length; i++) {
                            const element = form.elements[i];
                            const name = element.name;
                            
                            // Skip elements without names or submit buttons
                            if (!name || element.type === 'submit' || element.type === 'button') {
                                continue;
                            }
                            
                            // Handle checkboxes explicitly (both checked and unchecked)
                            if (element.type === 'checkbox') {
                                flatConfig[name] = element.checked;
                            }
                            // Handle radio buttons
                            else if (element.type === 'radio') {
                                if (element.checked) {
                                    flatConfig[name] = element.value;
                                }
                            }
                            // Handle select elements (including multi-select)
                            else if (element.tagName === 'SELECT') {
                                if (element.multiple) {
                                    // Multi-select: get all selected options
                                    const selectedValues = Array.from(element.selectedOptions).map(opt => opt.value);
                                    flatConfig[name] = selectedValues;
                                } else {
                                    // Single select: handled by FormData, but ensure it's captured
                                    if (!(name in flatConfig)) {
                                        flatConfig[name] = element.value;
                                    }
                                }
                            }
                            // Handle textarea
                            else if (element.tagName === 'TEXTAREA') {
                                // Textarea: handled by FormData, but ensure it's captured
                                if (!(name in flatConfig)) {
                                    flatConfig[name] = element.value;
                                }
                            }
                        }
                        
                        // Now process FormData for other field types
                        for (const [key, value] of formData.entries()) {
                            // Skip checkboxes - we already handled them above
                            const element = form.elements[key];
                            if (element && element.type === 'checkbox') {
                                continue; // Already processed
                            }
                            // Skip multi-select - we already handled them above
                            if (element && element.tagName === 'SELECT' && element.multiple) {
                                continue; // Already processed
                            }
                            
                            // Get schema property type if available
                            const propSchema = this.getSchemaPropertyType(schema, key);
                            const propType = propSchema ? propSchema.type : null;
                            
                            // Handle based on schema type or field name patterns
                            if (propType === 'array') {
                                // Check if this is a file upload widget (JSON array in hidden input)
                                if (propSchema && propSchema['x-widget'] === 'file-upload') {
                                    try {
                                        const jsonValue = JSON.parse(value);
                                        if (Array.isArray(jsonValue)) {
                                            flatConfig[key] = jsonValue;
                                            console.log(`File upload array field ${key}: parsed JSON array with ${jsonValue.length} items`);
                                        } else {
                                            // Fallback to empty array
                                            flatConfig[key] = [];
                                        }
                                    } catch (e) {
                                        // Not valid JSON, use empty array or try comma-separated
                                        if (value && value.trim()) {
                                            const arrayValue = value.split(',').map(v => v.trim()).filter(v => v);
                                            flatConfig[key] = arrayValue;
                                        } else {
                                            flatConfig[key] = [];
                                        }
                                    }
                                } else {
                                    // Regular array: convert comma-separated string to array
                                    const arrayValue = value ? value.split(',').map(v => v.trim()).filter(v => v) : [];
                                    flatConfig[key] = arrayValue;
                                }
                            } else if (propType === 'integer') {
                                const numValue = parseInt(value, 10);
                                flatConfig[key] = isNaN(numValue) ? (propSchema && propSchema.default !== undefined ? propSchema.default : 0) : numValue;
                            } else if (propType === 'number') {
                                const numValue = parseFloat(value);
                                flatConfig[key] = isNaN(numValue) ? (propSchema && propSchema.default !== undefined ? propSchema.default : 0) : numValue;
                            } else if (propType === 'boolean') {
                                // Boolean from FormData (shouldn't happen for checkboxes, but handle it)
                                flatConfig[key] = value === 'on' || value === 'true' || value === true;
                            } else {
                                // String or other types
                                // Check if it's a number field by name pattern (fallback if no schema)
                                if (!propType && (key.includes('duration') || key.includes('interval') || 
                                    key.includes('timeout') || key.includes('teams') || key.includes('fps') ||
                                    key.includes('bits') || key.includes('nanoseconds') || key.includes('hz'))) {
                                    const numValue = parseFloat(value);
                                    if (!isNaN(numValue)) {
                                        flatConfig[key] = Number.isInteger(numValue) ? parseInt(value, 10) : numValue;
                                    } else {
                                        flatConfig[key] = value;
                                    }
                                } else {
                                    flatConfig[key] = value;
                                }
                            }
                        }
                        
                        // Handle unchecked checkboxes using schema (if available)
                        if (schema && schema.properties) {
                            const collectBooleanFields = (props, prefix = '') => {
                                const boolFields = [];
                                for (const [key, prop] of Object.entries(props)) {
                                    const fullKey = prefix ? `${prefix}.${key}` : key;
                                    if (prop.type === 'boolean') {
                                        boolFields.push(fullKey);
                                    } else if (prop.type === 'object' && prop.properties) {
                                        boolFields.push(...collectBooleanFields(prop.properties, fullKey));
                                    }
                                }
                                return boolFields;
                            };
                            
                            const allBoolFields = collectBooleanFields(schema.properties);
                            allBoolFields.forEach(key => {
                                // Only set to false if the field is completely missing from flatConfig
                                // Don't override existing false values - they're explicitly set by the user
                                if (!(key in flatConfig)) {
                                    flatConfig[key] = false;
                                }
                            });
                        }
                        
                        // Convert dot notation to nested object
                        const dotToNested = (obj) => {
                            const result = {};
                            for (const key in obj) {
                                const parts = key.split('.');
                                let current = result;
                                for (let i = 0; i < parts.length - 1; i++) {
                                    if (!current[parts[i]]) {
                                        current[parts[i]] = {};
                                    }
                                    current = current[parts[i]];
                                }
                                current[parts[parts.length - 1]] = obj[key];
                            }
                            return result;
                        };
                        
                        const config = dotToNested(flatConfig);
                        
                        console.log('Saving config for', pluginId, ':', config);
                        console.log('Flat config before nesting:', flatConfig);
                        // Debug logging for live_priority
                        if (pluginId === 'football-scoreboard') {
                            console.log('[DEBUG] NFL live_priority in flatConfig:', flatConfig['nfl.live_priority']);
                            console.log('[DEBUG] NCAA FB live_priority in flatConfig:', flatConfig['ncaa_fb.live_priority']);
                            console.log('[DEBUG] NFL live_priority in nested config:', config.nfl?.live_priority);
                            console.log('[DEBUG] NCAA FB live_priority in nested config:', config.ncaa_fb?.live_priority);
                        }
                        
                        // Save to backend
                        const response = await fetch('/api/v3/plugins/config', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                plugin_id: pluginId,
                                config: config
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (data.status === 'success') {
                            this.showNotification('Configuration saved successfully', 'success');
                            // Reload plugin config to reflect changes
                            await this.loadPluginConfig(pluginId);
                        } else {
                            this.showNotification('Error saving configuration: ' + data.message, 'error');
                        }
                    } catch (error) {
                        console.error('Error saving plugin config:', error);
                        this.showNotification('Error saving configuration: ' + error.message, 'error');
                    }
                },

                formatCommitInfo(commit, branch) {
                    // Handle null, undefined, or empty string
                    const commitStr = (commit && String(commit).trim()) || '';
                    const branchStr = (branch && String(branch).trim()) || '';
                    
                    if (!commitStr && !branchStr) return 'Unknown';
                    
                    const shortCommit = commitStr.length >= 7 ? commitStr.substring(0, 7) : commitStr;

                    if (branchStr && shortCommit) {
                        return `${branchStr} · ${shortCommit}`;
                    }
                    if (branchStr) {
                        return branchStr;
                    }
                    if (shortCommit) {
                        return shortCommit;
                    }
                    return 'Unknown';
                },

                formatDateInfo(dateString) {
                    // Handle null, undefined, or empty string
                    if (!dateString || !String(dateString).trim()) return 'Unknown';
                    
                    try {
                        const date = new Date(dateString);
                        // Check if date is valid
                        if (isNaN(date.getTime())) {
                            return 'Unknown';
                        }
                        
                        const now = new Date();
                        const diffTime = Math.abs(now - date);
                        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                        
                        if (diffDays < 1) {
                            return 'Today';
                        } else if (diffDays < 2) {
                            return 'Yesterday';
                        } else if (diffDays < 7) {
                            return `${diffDays} days ago`;
                        } else if (diffDays < 30) {
                            const weeks = Math.floor(diffDays / 7);
                            return `${weeks} ${weeks === 1 ? 'week' : 'weeks'} ago`;
                        } else {
                            // Return formatted date for older items
                            return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                        }
                    } catch (e) {
                        console.error('Error formatting date:', e, dateString);
                        return 'Unknown';
                    }
                }
            }
        }

        // ===== Nested Section Toggle =====
        window.toggleNestedSection = function(sectionId) {
            const content = document.getElementById(sectionId);
            const icon = document.getElementById(sectionId + '-icon');
            
            if (!content || !icon) return;
            
            // Check if content is hidden (handle both explicit 'none' and empty string for initial state)
            const isHidden = content.style.display === 'none';
            
            if (isHidden) {
                // Show the section
                content.style.display = 'block';
                icon.classList.remove('fa-chevron-right');
                icon.classList.add('fa-chevron-down');
            } else {
                // Hide the section
                content.style.display = 'none';
                icon.classList.remove('fa-chevron-down');
                icon.classList.add('fa-chevron-right');
            }
        };

        // ===== Display Preview Functions (from v2) =====
        
        function updateDisplayPreview(data) {
            const preview = document.getElementById('displayPreview');
            const stage = document.getElementById('previewStage');
            const img = document.getElementById('displayImage');
            const canvas = document.getElementById('gridOverlay');
            const ledCanvas = document.getElementById('ledCanvas');
            const placeholder = document.getElementById('displayPlaceholder');
            
            if (!stage || !img || !placeholder) return; // Not on overview page

            if (data.image) {
                // Show stage
                placeholder.style.display = 'none';
                stage.style.display = 'inline-block';

                // Current scale from slider
                const scale = parseInt(document.getElementById('scaleRange')?.value || '8');

                // Update image and meta label
                img.style.imageRendering = 'pixelated';
                img.onload = () => {
                    renderLedDots();
                };
                img.src = `data:image/png;base64,${data.image}`;
                
                const meta = document.getElementById('previewMeta');
                if (meta) {
                    meta.textContent = `${data.width || 128} x ${data.height || 64} @ ${scale}x`;
                }

                // Size the canvases to match
                const width = (data.width || 128) * scale;
                const height = (data.height || 64) * scale;
                img.style.width = width + 'px';
                img.style.height = height + 'px';
                ledCanvas.width = width;
                ledCanvas.height = height;
                canvas.width = width;
                canvas.height = height;
                drawGrid(canvas, data.width || 128, data.height || 64, scale);
                renderLedDots();
            } else {
                stage.style.display = 'none';
                placeholder.style.display = 'block';
                placeholder.innerHTML = `<div class="text-center text-gray-400 py-8">
                    <i class="fas fa-exclamation-triangle text-4xl mb-3"></i>
                    <p>No display data available</p>
                </div>`;
            }
        }

        function renderLedDots() {
            const ledCanvas = document.getElementById('ledCanvas');
            const img = document.getElementById('displayImage');
            const toggle = document.getElementById('toggleLedDots');

            if (!ledCanvas || !img || !toggle) {
                return;
            }

            const show = toggle.checked;

            if (!show) {
                // LED mode OFF: Show image, hide canvas
                img.style.visibility = 'visible';
                ledCanvas.style.display = 'none';
                const ctx = ledCanvas.getContext('2d');
                ctx.clearRect(0, 0, ledCanvas.width, ledCanvas.height);
                return;
            }

            // LED mode ON: Hide image (but keep layout space), show only dots on canvas
            img.style.visibility = 'hidden';
            ledCanvas.style.display = 'block';

            const scale = parseInt(document.getElementById('scaleRange')?.value || '8');
            const fillPct = parseInt(document.getElementById('dotFillRange')?.value || '75');
            const dotRadius = Math.max(1, Math.floor((scale * fillPct) / 200)); // radius in px

            const ctx = ledCanvas.getContext('2d', { willReadFrequently: true });
            ctx.clearRect(0, 0, ledCanvas.width, ledCanvas.height);

            // Create an offscreen canvas to sample pixel colors
            const off = document.createElement('canvas');
            const logicalWidth = Math.floor(ledCanvas.width / scale);
            const logicalHeight = Math.floor(ledCanvas.height / scale);
            off.width = logicalWidth;
            off.height = logicalHeight;
            const offCtx = off.getContext('2d', { willReadFrequently: true });

            // Draw the current image scaled down to logical LEDs to sample colors
            try {
                offCtx.drawImage(img, 0, 0, logicalWidth, logicalHeight);
            } catch (e) {
                console.error('Failed to draw image to offscreen canvas:', e);
                return;
            }

            // Fill canvas with black background (LED matrix bezel)
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.fillRect(0, 0, ledCanvas.width, ledCanvas.height);

            // Draw circular dots for each LED pixel
            let drawn = 0;
            for (let y = 0; y < logicalHeight; y++) {
                for (let x = 0; x < logicalWidth; x++) {
                    const pixel = offCtx.getImageData(x, y, 1, 1).data;
                    const r = pixel[0], g = pixel[1], b = pixel[2], a = pixel[3];

                    // Skip fully transparent or black pixels to reduce overdraw
                    if (a === 0 || (r|g|b) === 0) continue;

                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    const cx = Math.floor(x * scale + scale / 2);
                    const cy = Math.floor(y * scale + scale / 2);
                    ctx.beginPath();
                    ctx.arc(cx, cy, dotRadius, 0, Math.PI * 2);
                    ctx.fill();
                    drawn++;
                }
            }

            // If nothing was drawn (e.g., image not ready), hide overlay to show base image
            if (drawn === 0) {
                ledCanvas.style.display = 'none';
            }
        }

        function drawGrid(canvas, pixelWidth, pixelHeight, scale) {
            const toggle = document.getElementById('toggleGrid');
            if (!toggle || !toggle.checked) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            
            for (let x = 0; x <= pixelWidth; x++) {
                ctx.beginPath();
                ctx.moveTo(x * scale, 0);
                ctx.lineTo(x * scale, pixelHeight * scale);
                ctx.stroke();
            }
            
            for (let y = 0; y <= pixelHeight; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * scale);
                ctx.lineTo(pixelWidth * scale, y * scale);
                ctx.stroke();
            }
        }

        function takeScreenshot() {
            const img = document.getElementById('displayImage');
            if (img && img.src) {
                const link = document.createElement('a');
                link.download = `led_matrix_${new Date().getTime()}.png`;
                link.href = img.src;
                link.click();
            }
        }

        // ===== Plugin Management Functions =====

        // Make togglePluginFromTab global so Alpine.js can access it  
        window.togglePluginFromTab = async function(pluginId, enabled) {
            try {
                const response = await fetch('/api/v3/plugins/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ plugin_id: pluginId, enabled })
                });
                const data = await response.json();

                showNotification(data.message, data.status);

                // Update the plugin in window.installedPlugins
                if (window.installedPlugins) {
                    const plugin = window.installedPlugins.find(p => p.id === pluginId);
                    if (plugin) {
                        plugin.enabled = enabled;
                    }
                }

            } catch (error) {
                showNotification('Error toggling plugin: ' + error.message, 'error');
            }
        }

        // Helper function to get schema property type for a field path
        function getSchemaPropertyType(schema, path) {
            if (!schema || !schema.properties) return null;
            
            const parts = path.split('.');
            let current = schema.properties;
            
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                if (current && current[part]) {
                    if (i === parts.length - 1) {
                        return current[part];
                    } else if (current[part].properties) {
                        current = current[part].properties;
                    } else {
                        return null;
                    }
                } else {
                    return null;
                }
            }
            return null;
        }

        async function savePluginConfig(pluginId) {
            try {
                console.log('Saving config for plugin:', pluginId);
                
                // Load schema for type detection
                let schema = {};
                try {
                    const schemaResponse = await fetch(`/api/v3/plugins/schema?plugin_id=${pluginId}`);
                    const schemaData = await schemaResponse.json();
                    if (schemaData.status === 'success' && schemaData.data.schema) {
                        schema = schemaData.data.schema;
                    }
                } catch (e) {
                    console.warn('Could not load schema for type detection:', e);
                }
                
                // Find the form in the active plugin tab
                // Alpine.js hides/shows elements with display:none, so we look for the currently visible one
                const allForms = document.querySelectorAll('form[x-on\\:submit\\.prevent]');
                console.log('Found forms:', allForms.length);
                
                let form = null;
                for (const f of allForms) {
                    const parent = f.closest('[x-show]');
                    if (parent && parent.style.display !== 'none' && parent.offsetParent !== null) {
                        form = f;
                        console.log('Found visible form');
                        break;
                    }
                }
                
                if (!form) {
                    throw new Error('Form not found for plugin ' + pluginId);
                }

                const formData = new FormData(form);
                const flatConfig = {};

                // First, collect all checkbox states (including unchecked ones)
                // Unchecked checkboxes don't appear in FormData, so we need to iterate form elements
                for (let i = 0; i < form.elements.length; i++) {
                    const element = form.elements[i];
                    const name = element.name;
                    
                    // Skip elements without names or submit buttons
                    if (!name || element.type === 'submit' || element.type === 'button') {
                        continue;
                    }
                    
                    // Handle checkboxes explicitly (both checked and unchecked)
                    if (element.type === 'checkbox') {
                        flatConfig[name] = element.checked;
                    }
                    // Handle radio buttons
                    else if (element.type === 'radio') {
                        if (element.checked) {
                            flatConfig[name] = element.value;
                        }
                    }
                    // Handle select elements (including multi-select)
                    else if (element.tagName === 'SELECT') {
                        if (element.multiple) {
                            // Multi-select: get all selected options
                            const selectedValues = Array.from(element.selectedOptions).map(opt => opt.value);
                            flatConfig[name] = selectedValues;
                        } else {
                            // Single select: handled by FormData, but ensure it's captured
                            if (!(name in flatConfig)) {
                                flatConfig[name] = element.value;
                            }
                        }
                    }
                    // Handle textarea
                    else if (element.tagName === 'TEXTAREA') {
                        // Textarea: handled by FormData, but ensure it's captured
                        if (!(name in flatConfig)) {
                            flatConfig[name] = element.value;
                        }
                    }
                }

                // Now process FormData for other field types
                for (const [key, value] of formData.entries()) {
                    // Skip checkboxes - we already handled them above
                    const element = form.elements[key];
                    if (element && element.type === 'checkbox') {
                        continue; // Already processed
                    }
                    // Skip multi-select - we already handled them above
                    if (element && element.tagName === 'SELECT' && element.multiple) {
                        continue; // Already processed
                    }
                    
                    // Get schema property type if available
                    const propSchema = getSchemaPropertyType(schema, key);
                    const propType = propSchema ? propSchema.type : null;
                    
                    // Handle based on schema type or field name patterns
                    if (propType === 'array') {
                        // Check if this is a file upload widget (JSON array in hidden input)
                        if (propSchema && propSchema['x-widget'] === 'file-upload') {
                            try {
                                const jsonValue = JSON.parse(value);
                                if (Array.isArray(jsonValue)) {
                                    flatConfig[key] = jsonValue;
                                    console.log(`File upload array field ${key}: parsed JSON array with ${jsonValue.length} items`);
                                } else {
                                    // Fallback to empty array
                                    flatConfig[key] = [];
                                }
                            } catch (e) {
                                // Not valid JSON, use empty array or try comma-separated
                                if (value && value.trim()) {
                                    const arrayValue = value.split(',').map(v => v.trim()).filter(v => v);
                                    flatConfig[key] = arrayValue;
                                } else {
                                    flatConfig[key] = [];
                                }
                            }
                        } else {
                            // Regular array: convert comma-separated string to array
                            const arrayValue = value ? value.split(',').map(v => v.trim()).filter(v => v) : [];
                            flatConfig[key] = arrayValue;
                        }
                    } else if (propType === 'integer') {
                        const numValue = parseInt(value, 10);
                        flatConfig[key] = isNaN(numValue) ? (propSchema && propSchema.default !== undefined ? propSchema.default : 0) : numValue;
                    } else if (propType === 'number') {
                        const numValue = parseFloat(value);
                        flatConfig[key] = isNaN(numValue) ? (propSchema && propSchema.default !== undefined ? propSchema.default : 0) : numValue;
                    } else if (propType === 'boolean') {
                        // Boolean from FormData (shouldn't happen for checkboxes, but handle it)
                        flatConfig[key] = value === 'on' || value === 'true' || value === true;
                    } else {
                        // String or other types
                        // Check if it's a number field by name pattern (fallback if no schema)
                        if (!propType && (key.includes('duration') || key.includes('interval') || 
                            key.includes('timeout') || key.includes('teams') || key.includes('fps') ||
                            key.includes('bits') || key.includes('nanoseconds') || key.includes('hz'))) {
                            const numValue = parseFloat(value);
                            if (!isNaN(numValue)) {
                                flatConfig[key] = Number.isInteger(numValue) ? parseInt(value, 10) : numValue;
                            } else {
                                flatConfig[key] = value;
                            }
                        } else {
                            flatConfig[key] = value;
                        }
                    }
                }

                // Handle unchecked checkboxes using schema (if available)
                if (schema && schema.properties) {
                    const collectBooleanFields = (props, prefix = '') => {
                        const boolFields = [];
                        for (const [key, prop] of Object.entries(props)) {
                            const fullKey = prefix ? `${prefix}.${key}` : key;
                            if (prop.type === 'boolean') {
                                boolFields.push(fullKey);
                            } else if (prop.type === 'object' && prop.properties) {
                                boolFields.push(...collectBooleanFields(prop.properties, fullKey));
                            }
                        }
                        return boolFields;
                    };
                    
                    const allBoolFields = collectBooleanFields(schema.properties);
                    allBoolFields.forEach(key => {
                        if (!(key in flatConfig)) {
                            flatConfig[key] = false;
                        }
                    });
                }

                // Convert dot notation to nested object
                const dotToNested = (obj) => {
                    const result = {};
                    for (const key in obj) {
                        const parts = key.split('.');
                        let current = result;
                        for (let i = 0; i < parts.length - 1; i++) {
                            if (!current[parts[i]]) {
                                current[parts[i]] = {};
                            }
                            current = current[parts[i]];
                        }
                        current[parts[parts.length - 1]] = obj[key];
                    }
                    return result;
                };

                const config = dotToNested(flatConfig);

                console.log('Saving config for', pluginId, ':', config);
                console.log('Flat config before nesting:', flatConfig);

                // Save to backend
                const response = await fetch('/api/v3/plugins/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ plugin_id: pluginId, config })
                });

                const data = await response.json();

                if (data.status === 'success') {
                    showNotification(`Configuration saved for ${pluginId}`, 'success');
                } else {
                    throw new Error(data.message || 'Failed to save configuration');
                }

            } catch (error) {
                console.error('Error saving plugin configuration:', error);
                showNotification('Error saving plugin configuration: ' + error.message, 'error');
            }
        }
        
        // Notification helper function
        function showNotification(message, type = 'info') {
            console.log(`[${type.toUpperCase()}]`, message);
            
            // Create a simple toast notification
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 px-6 py-3 rounded-lg shadow-lg z-50 ${
                type === 'success' ? 'bg-green-500' :
                type === 'error' ? 'bg-red-500' :
                'bg-blue-500'
            } text-white`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Fade out and remove after 3 seconds
            setTimeout(() => {
                notification.style.transition = 'opacity 0.5s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 3000);
        }

        function getAppComponent() {
            if (window.Alpine) {
                const appElement = document.querySelector('[x-data="app()"]');
                if (appElement && appElement._x_dataStack && appElement._x_dataStack[0]) {
                    return appElement._x_dataStack[0];
                }
            }
            return null;
        }

        async function updatePlugin(pluginId) {
            try {
                showNotification(`Updating ${pluginId}...`, 'info');

                const response = await fetch('/api/v3/plugins/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ plugin_id: pluginId })
                });
                const data = await response.json();

                showNotification(data.message, data.status);

                if (data.status === 'success') {
                    // Refresh the plugin list
                    const appComponent = getAppComponent();
                    if (appComponent && typeof appComponent.loadInstalledPlugins === 'function') {
                        await appComponent.loadInstalledPlugins();
                    }
                }
            } catch (error) {
                showNotification('Error updating plugin: ' + error.message, 'error');
            }
        }

        async function updateAllPlugins() {
            try {
                const plugins = Array.isArray(window.installedPlugins) ? window.installedPlugins : [];

                if (!plugins.length) {
                    showNotification('No installed plugins to update.', 'warning');
                    return;
                }

                showNotification(`Checking ${plugins.length} plugin${plugins.length === 1 ? '' : 's'} for updates...`, 'info');

                let successCount = 0;
                let failureCount = 0;

                for (const plugin of plugins) {
                    const pluginId = plugin.id;
                    const pluginName = plugin.name || pluginId;

                    try {
                        const response = await fetch('/api/v3/plugins/update', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ plugin_id: pluginId })
                        });

                        const data = await response.json();
                        const status = data.status || 'info';
                        const message = data.message || `Checked ${pluginName}`;

                        showNotification(message, status);

                        if (status === 'success') {
                            successCount += 1;
                        } else {
                            failureCount += 1;
                        }
                    } catch (error) {
                        failureCount += 1;
                        showNotification(`Error updating ${pluginName}: ${error.message}`, 'error');
                    }
                }

                const appComponent = getAppComponent();
                if (appComponent && typeof appComponent.loadInstalledPlugins === 'function') {
                    await appComponent.loadInstalledPlugins();
                }

                if (failureCount === 0) {
                    showNotification(`Finished checking ${successCount} plugin${successCount === 1 ? '' : 's'} for updates.`, 'success');
                } else {
                    showNotification(`Updated ${successCount} plugin${successCount === 1 ? '' : 's'} with ${failureCount} failure${failureCount === 1 ? '' : 's'}. Check logs for details.`, 'error');
                }
            } catch (error) {
                console.error('Bulk plugin update failed:', error);
                showNotification('Failed to update all plugins: ' + error.message, 'error');
            }
        }

        window.updateAllPlugins = updateAllPlugins;


        async function uninstallPlugin(pluginId) {
            try {
                // Get plugin info from window.installedPlugins
                const plugin = window.installedPlugins ? window.installedPlugins.find(p => p.id === pluginId) : null;
                const pluginName = plugin ? (plugin.name || pluginId) : pluginId;

                if (!confirm(`Are you sure you want to uninstall ${pluginName}?`)) {
                    return;
                }

                showNotification(`Uninstalling ${pluginName}...`, 'info');

                const response = await fetch('/api/v3/plugins/uninstall', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ plugin_id: pluginId })
                });
                const data = await response.json();

                showNotification(data.message, data.status);

                if (data.status === 'success') {
                    // Refresh the plugin list
                    await app.loadInstalledPlugins();
                }
            } catch (error) {
                showNotification('Error uninstalling plugin: ' + error.message, 'error');
            }
        }

        async function refreshPlugin(pluginId) {
            try {
                // Switch to the plugin manager tab briefly to refresh
                const originalTab = app.activeTab;
                app.activeTab = 'plugins';

                // Wait a moment then switch back
                setTimeout(() => {
                    app.activeTab = originalTab;
                    app.showNotification(`Refreshed ${pluginId}`, 'success');
                }, 100);

            } catch (error) {
                app.showNotification('Error refreshing plugin: ' + error.message, 'error');
            }
        }

        // Format commit information for display
        function formatCommitInfo(commit, branch) {
            if (!commit && !branch) return 'Unknown';
            const shortCommit = commit ? String(commit).substring(0, 7) : '';
            const branchText = branch ? String(branch) : '';

            if (branchText && shortCommit) {
                return `${branchText} · ${shortCommit}`;
            }
            if (branchText) {
                return branchText;
            }
            if (shortCommit) {
                return shortCommit;
            }
            return 'Latest';
        }

        // Format date for display
        function formatDateInfo(dateString) {
            if (!dateString) return 'Unknown';
            
            try {
                const date = new Date(dateString);
                const now = new Date();
                const diffTime = Math.abs(now - date);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                
                if (diffDays < 1) {
                    return 'Today';
                } else if (diffDays < 2) {
                    return 'Yesterday';
                } else if (diffDays < 7) {
                    return `${diffDays} days ago`;
                } else if (diffDays < 30) {
                    const weeks = Math.floor(diffDays / 7);
                    return `${weeks} ${weeks === 1 ? 'week' : 'weeks'} ago`;
                } else {
                    // Return formatted date for older items
                    return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                }
            } catch (e) {
                return dateString;
            }
        }

        // Make functions available to Alpine.js
        window.formatCommitInfo = formatCommitInfo;
        window.formatDateInfo = formatDateInfo;

    </script>

    <!-- Custom v3 JavaScript -->
    <script src="{{ url_for('static', filename='v3/app.js') }}"></script>
</body>
</html>
