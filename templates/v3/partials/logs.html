<div class="bg-white rounded-lg shadow p-6">
    <div class="border-b border-gray-200 pb-4 mb-6">
        <h2 class="text-lg font-semibold text-gray-900">System Logs</h2>
        <p class="mt-1 text-sm text-gray-600">View real-time logs from the LED matrix service for troubleshooting.</p>
    </div>

    <!-- Controls -->
    <div class="flex flex-wrap items-center justify-between gap-4 mb-6">
        <div class="flex items-center space-x-4">
            <!-- Log Mode Toggle -->
            <div class="flex items-center space-x-2">
                <label class="flex items-center">
                    <input type="checkbox" id="log-realtime-toggle" class="form-control h-4 w-4" checked>
                    <span class="ml-2 text-sm font-medium">Real-time</span>
                </label>
                <span class="text-sm text-gray-600">|</span>
                <button id="refresh-logs-btn" class="btn bg-gray-600 hover:bg-gray-700 text-white px-3 py-1 rounded text-sm">
                    <i class="fas fa-sync-alt mr-1"></i>Refresh
                </button>
            </div>

            <!-- Log Level Filter -->
            <select id="log-level-filter" class="form-control text-sm">
                <option value="">All Levels</option>
                <option value="ERROR">Errors Only</option>
                <option value="WARNING">Warnings & Errors</option>
                <option value="INFO">Info & Above</option>
            </select>

            <!-- Search -->
            <div class="relative">
                <input type="text" id="log-search" placeholder="Search logs..." class="form-control text-sm pl-8 pr-4 py-1 w-48">
                <i class="fas fa-search absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 text-xs"></i>
            </div>
        </div>

        <div class="flex items-center space-x-2">
            <!-- Auto-scroll toggle -->
            <label class="flex items-center">
                <input type="checkbox" id="log-autoscroll" class="form-control h-4 w-4" checked>
                <span class="ml-2 text-sm">Auto-scroll</span>
            </label>

            <!-- Clear logs -->
            <button id="clear-logs-btn" class="btn bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm">
                <i class="fas fa-trash mr-1"></i>Clear
            </button>

            <!-- Download logs -->
            <button id="download-logs-btn" class="btn bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm">
                <i class="fas fa-download mr-1"></i>Download
            </button>
        </div>
    </div>

    <!-- Log Display -->
    <div class="relative">
        <div id="logs-container" class="bg-gray-900 text-gray-100 font-mono text-sm rounded-lg p-3 border border-gray-700 shadow-inner overflow-y-auto" style="height: calc(100vh - 400px); min-height: 400px; max-height: calc(100vh - 200px);">
            <div id="logs-loading" class="flex items-center justify-center h-full text-gray-400">
                <div class="text-center">
                    <i class="fas fa-spinner fa-spin text-2xl mb-2"></i>
                    <p>Loading logs...</p>
                </div>
            </div>
            <div id="logs-display" class="hidden space-y-0.5">
                <!-- Logs will be inserted here -->
            </div>
            <div id="logs-empty" class="hidden flex items-center justify-center h-full text-gray-400">
                <div class="text-center">
                    <i class="fas fa-file-alt text-4xl mb-2"></i>
                    <p>No logs available</p>
                    <p class="text-sm mt-2">Logs will appear here when the service runs</p>
                </div>
            </div>
        </div>

        <!-- Log stats -->
        <div id="log-stats" class="absolute top-2 right-2 bg-black bg-opacity-70 text-white text-xs px-3 py-1.5 rounded-md backdrop-blur-sm hidden">
            <i class="fas fa-list-ul mr-1"></i>
            <span id="log-count">0</span> entries
        </div>
    </div>

    <!-- Connection Status -->
    <div id="log-connection-status" class="mt-4 text-sm text-gray-600 flex items-center space-x-2">
        <div class="w-2 h-2 bg-green-500 rounded-full"></div>
        <span>Connected to log stream</span>
    </div>
</div>

<script>
// Global variables
let logsEventSource = null;
let allLogs = [];
let filteredLogs = [];
let logContainer = null;
let logsContent = null;
let isRealtime = true;
const MAX_LOGS = 500; // Maximum number of logs to keep in memory

// Initialize immediately (this script runs when the partial is loaded)
(function() {
    logContainer = document.getElementById('logs-container');
    logsContent = document.getElementById('logs-display');

    initializeLogs();

    // Event listeners
    document.getElementById('log-realtime-toggle').addEventListener('change', toggleRealtime);
    document.getElementById('refresh-logs-btn').addEventListener('click', refreshLogs);
    document.getElementById('log-level-filter').addEventListener('change', filterLogs);
    document.getElementById('log-search').addEventListener('input', filterLogs);
    document.getElementById('log-autoscroll').addEventListener('change', toggleAutoscroll);
    document.getElementById('clear-logs-btn').addEventListener('click', clearLogs);
    document.getElementById('download-logs-btn').addEventListener('click', downloadLogs);

    // Handle window resize for responsive height
    window.addEventListener('resize', function() {
        if (logContainer) {
            // Force a reflow to update calc() values
            logContainer.style.display = 'none';
            logContainer.offsetHeight; // Trigger reflow
            logContainer.style.display = '';
        }
    });
})();

function initializeLogs() {
    // Load initial logs
    loadLogs();

    // Setup SSE for real-time logs
    setupRealtimeLogs();

    // Setup auto-scroll
    setupAutoscroll();
}

function loadLogs() {
    showLoading();

    fetch('/api/v3/logs')
        .then(response => response.json())
        .then(data => {
            hideLoading();

            if (data.status === 'success' && data.data && data.data.logs) {
                processLogs(data.data.logs);
                updateLogStats();
            } else {
                showEmptyState();
            }
        })
        .catch(error => {
            hideLoading();
            showError('Failed to load logs: ' + error.message);
        });
}

function setupRealtimeLogs() {
    if (logsEventSource) {
        logsEventSource.close();
    }

    logsEventSource = new EventSource('/api/v3/stream/logs');

    logsEventSource.onopen = function() {
        document.getElementById('log-connection-status').innerHTML = `
            <div class="w-2 h-2 bg-green-500 rounded-full"></div>
            <span>Connected to log stream</span>
        `;
    };

    logsEventSource.onmessage = function(event) {
        const data = JSON.parse(event.data);

        if (data.logs && isRealtime) {
            processLogs(data.logs, true);
            updateLogStats();

            const autoscrollEl = document.getElementById('log-autoscroll');
            if (autoscrollEl && autoscrollEl.checked) {
                scrollToBottom();
            }
        }
    };

    logsEventSource.onerror = function() {
        document.getElementById('log-connection-status').innerHTML = `
            <div class="w-2 h-2 bg-red-500 rounded-full"></div>
            <span>Disconnected from log stream</span>
        `;

        // Attempt to reconnect after 5 seconds
        setTimeout(setupRealtimeLogs, 5000);
    };
}

function processLogs(logsText, append = false) {
    if (!append) {
        allLogs = [];
        logsContent.innerHTML = '';
    }

    // Parse journalctl output
    const lines = logsText.split('\n').filter(line => line.trim());

    lines.forEach(line => {
        // Skip empty lines
        if (!line.trim()) return;

        // Try to parse journalctl format: "MMM DD HH:MM:SS hostname service[pid]: message"
        // Example: "Oct 13 14:23:45 raspberrypi ledmatrix[1234]: INFO: Starting display"
        
        let timestamp = '';
        let level = 'INFO';
        let message = line;
        
        // Extract timestamp (first part before hostname)
        const timestampMatch = line.match(/^([A-Z][a-z]{2}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})/);
        if (timestampMatch) {
            timestamp = timestampMatch[1];
            
            // Find the message part (after service name and pid)
            const messageMatch = line.match(/:\s*(.+)$/);
            if (messageMatch) {
                message = messageMatch[1];
                
                // Detect log level from message
                if (message.match(/\b(ERROR|CRITICAL|FATAL)\b/i)) {
                    level = 'ERROR';
                } else if (message.match(/\b(WARNING|WARN)\b/i)) {
                    level = 'WARNING';
                } else if (message.match(/\bDEBUG\b/i)) {
                    level = 'DEBUG';
                } else if (message.match(/\bINFO\b/i)) {
                    level = 'INFO';
                }
                
                // Clean up level prefix from message if it exists
                message = message.replace(/^(ERROR|WARNING|WARN|INFO|DEBUG):\s*/i, '');
            }
        } else {
            // If no timestamp, use current time
            timestamp = new Date().toLocaleString('en-US', {
                month: 'short',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        }

        const logEntry = {
            timestamp: timestamp,
            level: level,
            message: message,
            raw: line,
            id: Date.now() + Math.random()
        };
        
        // Don't add duplicate entries when appending
        if (!append || !allLogs.find(log => log.raw === line)) {
            allLogs.push(logEntry);
        }
    });

    // Trim logs if we exceed the maximum
    if (allLogs.length > MAX_LOGS) {
        allLogs = allLogs.slice(-MAX_LOGS);
    }

    filterLogs();
}

function renderLogs() {
    if (filteredLogs.length === 0) {
        showEmptyState();
        return;
    }

    logsContent.innerHTML = '';

    filteredLogs.forEach(log => {
        const logElement = document.createElement('div');
        logElement.className = `log-entry py-1 px-2 hover:bg-gray-800 rounded transition-colors duration-150 ${getLogLevelClass(log.level)}`;
        logElement.innerHTML = `
            <div class="flex items-start gap-3 text-xs font-mono">
                <span class="log-timestamp text-gray-500 flex-shrink-0 w-32">${escapeHtml(log.timestamp)}</span>
                <span class="log-level flex-shrink-0 px-2 py-0.5 rounded text-xs font-semibold ${getLogLevelBadgeClass(log.level)}">${log.level}</span>
                <span class="log-message flex-1 ${getLogLevelTextClass(log.level)} break-words">${escapeHtml(log.message)}</span>
            </div>
        `;
        logsContent.appendChild(logElement);
    });

    logsContent.classList.remove('hidden');
    document.getElementById('logs-loading').classList.add('hidden');
    document.getElementById('logs-empty').classList.add('hidden');
}

function getLogLevelClass(level) {
    // Background color for the entire log entry row
    const classes = {
        'ERROR': 'bg-red-900 bg-opacity-10',
        'WARNING': 'bg-yellow-900 bg-opacity-10',
        'INFO': '',
        'DEBUG': 'bg-gray-800 bg-opacity-30'
    };
    return classes[level] || '';
}

function getLogLevelBadgeClass(level) {
    const classes = {
        'ERROR': 'bg-red-600 text-white',
        'WARNING': 'bg-yellow-600 text-white',
        'INFO': 'bg-blue-600 text-white',
        'DEBUG': 'bg-gray-600 text-white'
    };
    return classes[level] || 'bg-gray-600 text-white';
}

function getLogLevelTextClass(level) {
    const classes = {
        'ERROR': 'text-red-300',
        'WARNING': 'text-yellow-300',
        'INFO': 'text-gray-200',
        'DEBUG': 'text-gray-400'
    };
    return classes[level] || 'text-gray-300';
}

function filterLogs() {
    const levelFilter = document.getElementById('log-level-filter').value;
    const searchTerm = document.getElementById('log-search').value.toLowerCase();

    filteredLogs = allLogs.filter(log => {
        // Level filter
        if (levelFilter) {
            const levels = {
                'ERROR': ['ERROR'],
                'WARNING': ['ERROR', 'WARNING'],
                'INFO': ['ERROR', 'WARNING', 'INFO']
            };

            if (!levels[levelFilter].includes(log.level)) {
                return false;
            }
        }

        // Search filter
        if (searchTerm && !log.message.toLowerCase().includes(searchTerm)) {
            return false;
        }

        return true;
    });

    renderLogs();
    updateLogStats();
}

function toggleRealtime() {
    isRealtime = document.getElementById('log-realtime-toggle').checked;

    if (isRealtime) {
        setupRealtimeLogs();
    } else if (logsEventSource) {
        logsEventSource.close();
        logsEventSource = null;
    }
}

function refreshLogs() {
    loadLogs();
    if (typeof showNotification !== 'undefined') {
        showNotification('Logs refreshed', 'success');
    }
}

function clearLogs() {
    allLogs = [];
    filteredLogs = [];
    logsContent.innerHTML = '';
    showEmptyState();
    updateLogStats();
    if (typeof showNotification !== 'undefined') {
        showNotification('Logs cleared', 'info');
    }
}

function downloadLogs() {
    if (filteredLogs.length === 0) {
        if (typeof showNotification !== 'undefined') {
            showNotification('No logs to download', 'warning');
        }
        return;
    }

    const logText = filteredLogs.map(log => log.raw).join('\n');
    const blob = new Blob([logText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `ledmatrix-logs-${new Date().toISOString().slice(0, 19)}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    if (typeof showNotification !== 'undefined') {
        showNotification('Logs downloaded', 'success');
    }
}

function setupAutoscroll() {
    const observer = new MutationObserver(scrollToBottom);
    observer.observe(logsContent, { childList: true });
}

function scrollToBottom() {
    const autoscrollEl = document.getElementById('log-autoscroll');
    if (autoscrollEl && autoscrollEl.checked && logContainer) {
        logContainer.scrollTop = logContainer.scrollHeight;
    }
}

function toggleAutoscroll() {
    const autoscrollEl = document.getElementById('log-autoscroll');
    if (!autoscrollEl || !autoscrollEl.checked) {
        // Don't auto-scroll if unchecked or element doesn't exist
        return;
    }

    // Scroll to bottom when re-enabled
    scrollToBottom();
}

function updateLogStats() {
    const stats = document.getElementById('log-stats');
    const count = document.getElementById('log-count');

    if (stats && count) {
        count.textContent = filteredLogs.length;
        stats.classList.remove('hidden');
    }
}

function showLoading() {
    document.getElementById('logs-loading').classList.remove('hidden');
    document.getElementById('logs-display').classList.add('hidden');
    document.getElementById('logs-empty').classList.add('hidden');
}

function hideLoading() {
    document.getElementById('logs-loading').classList.add('hidden');
}

function showEmptyState() {
    document.getElementById('logs-loading').classList.add('hidden');
    document.getElementById('logs-display').classList.add('hidden');
    document.getElementById('logs-empty').classList.remove('hidden');
    document.getElementById('log-stats').classList.add('hidden');
}

function showError(message) {
    logsContent.innerHTML = `<div class="text-red-400 p-4">${escapeHtml(message)}</div>`;
    logsContent.classList.remove('hidden');
}

// Utility function to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (logsEventSource) {
        logsEventSource.close();
    }
});
</script>
