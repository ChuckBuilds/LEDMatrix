#!/bin/bash
#
# Git pre-push hook for plugin repositories
# Automatically bumps the patch version in manifest.json before pushing
#
# This hook is self-contained and doesn't require external scripts.
# It works directly in the plugin repository on any development machine.
#
# Installation:
#   cd your-plugin-repo
#   cp scripts/git-hooks/pre-push-plugin-version .git/hooks/pre-push
#   chmod +x .git/hooks/pre-push

# Get the plugin directory (where .git is located)
PLUGIN_DIR="$(git rev-parse --show-toplevel)"
MANIFEST_PATH="$PLUGIN_DIR/manifest.json"

# Check if manifest.json exists
if [ ! -f "$MANIFEST_PATH" ]; then
    echo "Warning: manifest.json not found, skipping version bump"
    exit 0
fi

# Self-contained Python script to bump version (embedded in hook)
bump_version() {
    python3 << 'PYTHON_SCRIPT'
import json
import sys
from pathlib import Path
from datetime import datetime

manifest_path = sys.argv[1]

try:
    # Read manifest
    with open(manifest_path, 'r', encoding='utf-8') as f:
        manifest = json.load(f)
    
    # Get current version
    current_version = manifest.get('version', '1.0.0')
    
    # Parse and bump patch version (x.y.Z)
    try:
        parts = current_version.split('.')
        major = int(parts[0])
        minor = int(parts[1]) if len(parts) > 1 else 0
        patch = int(parts[2]) if len(parts) > 2 else 0
        patch += 1
        new_version = f"{major}.{minor}.{patch}"
    except (ValueError, IndexError):
        new_version = "1.0.0"
    
    if current_version == new_version:
        print(f"Version already at {current_version}, no bump needed")
        sys.exit(0)
    
    print(f"Bumping version: {current_version} → {new_version}")
    
    # Update main version field
    manifest['version'] = new_version
    
    # Update versions array - add new version at the beginning
    versions = manifest.get('versions', [])
    new_version_entry = {
        'version': new_version,
        'ledmatrix_min': versions[0].get('ledmatrix_min', '2.0.0') if versions else '2.0.0',
        'released': datetime.now().strftime('%Y-%m-%d')
    }
    versions.insert(0, new_version_entry)
    manifest['versions'] = versions
    
    # Update last_updated
    manifest['last_updated'] = datetime.now().strftime('%Y-%m-%d')
    
    # Write updated manifest
    with open(manifest_path, 'w', encoding='utf-8') as f:
        json.dump(manifest, f, indent=2, ensure_ascii=False)
    
    print(f"✓ Updated {manifest_path}")
    sys.exit(0)
    
except json.JSONDecodeError as e:
    print(f"Error: Invalid JSON in manifest.json: {e}")
    sys.exit(1)
except Exception as e:
    print(f"Error updating manifest: {e}")
    sys.exit(1)
PYTHON_SCRIPT
}

# Check if we're pushing to a remote (not just checking)
NEEDS_BUMP=0

while read local_ref local_sha remote_ref remote_sha; do
    if [ "$local_sha" != "0000000000000000000000000000000000000000" ]; then
        # We're actually pushing commits
        
        # Check if manifest.json has changes in the commits being pushed
        if git diff --quiet "$remote_sha" "$local_sha" -- "$MANIFEST_PATH" 2>/dev/null; then
            # manifest.json hasn't changed, check if any other files changed
            if ! git diff --quiet "$remote_sha" "$local_sha" -- ':!manifest.json' 2>/dev/null; then
                # Other files changed, but manifest.json didn't - need to bump version
                NEEDS_BUMP=1
                break
            fi
        fi
    fi
done

if [ $NEEDS_BUMP -eq 1 ]; then
    echo "Code changes detected, bumping plugin version..."
    
    # Run the embedded version bump function
    if bump_version "$MANIFEST_PATH"; then
        # Version was bumped, add manifest.json to staging
        git add "$MANIFEST_PATH"
        
        # Get the new version from manifest
        NEW_VERSION=$(python3 << 'PYTHON_SCRIPT'
import json
import sys
try:
    with open(sys.argv[1], 'r', encoding='utf-8') as f:
        manifest = json.load(f)
        print(manifest.get('version', '1.0.0'))
except:
    print('1.0.0')
PYTHON_SCRIPT
"$MANIFEST_PATH")
        
        # Check if we should create a tag (skip if SKIP_TAG environment variable is set)
        if [ -z "$SKIP_TAG" ]; then
            TAG_NAME="v${NEW_VERSION}"
            
            # Check if tag already exists
            if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
                echo "⚠️  Tag $TAG_NAME already exists, skipping tag creation"
            else
                # Create the tag
                if git tag -a "$TAG_NAME" -m "Version $NEW_VERSION" 2>/dev/null; then
                    echo "✓ Created git tag: $TAG_NAME"
                    
                    # Push the tag along with commits
                    # Note: We'll push tags after the commit is pushed
                    echo "  (Tag will be pushed after commits are pushed)"
                else
                    echo "⚠️  Warning: Failed to create tag $TAG_NAME"
                fi
            fi
        else
            echo "  (Tag creation skipped - SKIP_TAG is set)"
        fi
        
        echo "✓ Version bumped to $NEW_VERSION and manifest.json staged"
        echo ""
        echo "Note: The version bump has been staged but not committed."
        echo "You have two options:"
        echo "  1. Amend the current commit: git commit --amend --no-edit"
        echo "  2. Create a new commit: git commit -m 'chore: Bump version to $NEW_VERSION'"
        echo ""
        echo "After committing, push again:"
        echo "  git push --force-with-lease (if amended)"
        echo ""
        echo "Then push the new tag:"
        echo "  git push --tags"
        echo ""
        echo "Or push everything at once:"
        echo "  git push --force-with-lease && git push --tags"
    else
        echo "Warning: Version bump failed, continuing with push"
    fi
fi

# Note: Tags are created but not automatically pushed in the pre-push hook
# because the hook runs before the push. Users should push tags manually:
#   git push --tags
# Or tags can be pushed in a post-push hook if needed.

exit 0

